<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 太空射击 - 修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        #game-container { width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; padding: 15px 20px; color: #0ff; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #0ff; background: rgba(0,20,40,0.6); border: 2px solid #0ff; border-radius: 10px; }
        #score { top: 20px; left: 20px; }
        #wave { top: 20px; left: 260px; color: #ff0; border-color: #ff0; text-shadow: 0 0 10px #ff0; }
        #health { top: 20px; right: 20px; width: 180px; }
        #version { 
            position: absolute; 
            bottom: 10px; 
            right: 20px; 
            color: #0ff; 
            font-size: 12px; 
            opacity: 0.7;
            text-shadow: 0 0 5px #0ff;
        }
        .health-bar { width: 100%; height: 18px; background: rgba(0,0,0,0.5); border: 2px solid #0ff; border-radius: 9px; overflow: hidden; margin-top: 8px; }
        .health-fill { height: 100%; background: linear-gradient(90deg, #f00, #0f0); width: 100%; transition: width 0.3s; }
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(0,50,100,0.8) 0%, rgba(0,0,0,0.95) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #menu h1 { color: #0ff; font-size: 56px; margin-bottom: 20px; text-shadow: 0 0 30px #0ff; letter-spacing: 8px; }
        #menu p { color: #aaa; margin-bottom: 30px; text-align: center; font-size: 16px; }
        #menu button { padding: 18px 50px; font-size: 26px; background: linear-gradient(45deg, #00aaff, #0066ff); color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 30px rgba(0,170,255,0.6); transition: all 0.3s; }
        #menu button:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(0,170,255,0.9); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui">
        <div class="hud" id="score">SCORE: 0</div>
        <div class="hud" id="wave">WAVE: 1</div>
        <div class="hud" id="level" style="color: #0f0; border-color: #0f0; text-shadow: 0 0 10px #0f0; left: 440px;">LV: 1</div>
        <div class="hud" id="health">
            SHIELD
            <div class="health-bar">
                <div class="health-fill" id="health-fill"></div>
            </div>
        </div>
        <div id="version">v1.7.0 - Upgrade System</div>
    </div>
    <div id="menu">
        <h1>STAR FIGHTER</h1>
        <p>WASD 移动 | 空格 射击<br>修复版：更稳定的游戏体验</p>
        <button onclick="startGame()">开始游戏</button>
    </div>

<script>
// 游戏变量 - 使用更安全的数据结构
let scene, camera, renderer, player;
let bullets = [];
let enemies = [];
let particles = [];
let enemyBullets = [];
let score = 0, wave = 1, health = 100;
let playerLevel = 1; // 玩家等级
let isPlaying = false;
let keys = {};
let lastShot = 0;
let audioCtx;
let enemySpawnTimer = 0;
let frameCount = 0;

// 音效
function initAudio() { 
    audioCtx = new (window.AudioContext || window.webkitAudioContext)(); 
}

function playShootSound() {
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } catch(e) { console.log('Sound error:', e); }
}

function playExplosionSound() {
    if (!audioCtx) return;
    try {
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    } catch(e) { console.log('Sound error:', e); }
}

function playHitSound() {
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    } catch(e) { console.log('Sound error:', e); }
}

// 创建更短的血条
function createHealthBar(maxHp, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 32; // 更短
    canvas.height = 4; // 更矮
    const ctx = canvas.getContext('2d');
    
    function draw(hpPercent) {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, 32, 4);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, 32, 4);
        
        const percent = Math.max(0, Math.min(1, hpPercent));
        ctx.fillStyle = percent > 0.5 ? color : percent > 0.25 ? '#ff0' : '#f00';
        ctx.fillRect(1, 1, 30 * percent, 2);
    }
    
    draw(1);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(0.8, 0.1, 1); // 缩小显示
    sprite.position.y = 1.0; // 降低位置
    
    return { sprite, canvas, ctx, draw };
}

// 创建玩家飞船 - 带升级系统
function createPlayerShip(level = 1) {
    const group = new THREE.Group();
    
    // 根据等级设置外观参数
    const scale = 1 + (level - 1) * 0.3; // 每级增大30%
    const colors = [
        { body: 0x4488ff, wing: 0x3366cc, engine: 0x00aaff, cockpit: 0x00ffff }, // Lv1: 蓝色
        { body: 0x44ff88, wing: 0x33cc66, engine: 0x00ffaa, cockpit: 0x00ffcc }, // Lv2: 绿色
        { body: 0xff8844, wing: 0xcc6633, engine: 0xffaa00, cockpit: 0xffcc00 }, // Lv3: 橙色
        { body: 0xff4488, wing: 0xcc3366, engine: 0xff00aa, cockpit: 0xff00cc }, // Lv4: 粉色
        { body: 0xaa44ff, wing: 0x8833cc, engine: 0xaa00ff, cockpit: 0xcc00ff }, // Lv5: 紫色
    ];
    const color = colors[(level - 1) % colors.length];
    
    // 机身 - 随等级增大
    const bodyGeo = new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, 2.5 * scale, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: color.body, 
        metalness: 0.8 - (level * 0.05), 
        roughness: 0.2 - (level * 0.03),
        emissive: color.body,
        emissiveIntensity: (level - 1) * 0.1
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    group.add(body);
    
    // 驾驶舱 - 随等级增大并更华丽
    const cockpitGeo = new THREE.SphereGeometry(0.35 * scale, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const cockpitMat = new THREE.MeshPhysicalMaterial({ 
        color: color.cockpit, 
        transmission: 0.9, 
        transparent: true, 
        opacity: 0.6 + (level * 0.08),
        emissive: color.cockpit,
        emissiveIntensity: (level - 1) * 0.2
    });
    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
    cockpit.position.set(0, 0.4 * scale, 0.3 * scale);
    group.add(cockpit);
    
    // 机翼 - 随等级增大
    const wingGeo = new THREE.BoxGeometry(3 * scale, 0.1 * scale, 1.2 * scale);
    const wingMat = new THREE.MeshStandardMaterial({ 
        color: color.wing, 
        metalness: 0.8, 
        roughness: 0.2,
        emissive: color.wing,
        emissiveIntensity: (level - 1) * 0.15
    });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(0, -0.1 * scale, 0.3 * scale);
    wing.rotation.x = 0.2;
    group.add(wing);
    
    // 尾翼
    const tailGeo = new THREE.BoxGeometry(0.1 * scale, 0.8 * scale, 0.6 * scale);
    const tail = new THREE.Mesh(tailGeo, wingMat);
    tail.position.set(0, 0.4 * scale, 1 * scale);
    tail.rotation.x = 0.3;
    group.add(tail);
    
    // 引擎 - 随等级增加数量和大小
    const engineGeo = new THREE.CylinderGeometry(0.2 * scale, 0.35 * scale, 0.8 * scale, 8);
    engineGeo.rotateX(Math.PI / 2);
    const engineMat = new THREE.MeshBasicMaterial({ 
        color: color.engine, 
        emissive: color.engine,
        emissiveIntensity: 1 + (level - 1) * 0.5
    });
    
    // 根据等级增加引擎数量
    const enginePositions = [
        [[-0.6 * scale, -0.1 * scale, 1.2 * scale], [0.6 * scale, -0.1 * scale, 1.2 * scale]], // Lv1: 2引擎
        [[-0.8 * scale, -0.1 * scale, 1.2 * scale], [0.8 * scale, -0.1 * scale, 1.2 * scale], [-0.4 * scale, -0.15 * scale, 1.3 * scale], [0.4 * scale, -0.15 * scale, 1.3 * scale]], // Lv2: 4引擎
        [[-1 * scale, -0.1 * scale, 1.2 * scale], [1 * scale, -0.1 * scale, 1.2 * scale], [-0.5 * scale, -0.15 * scale, 1.4 * scale], [0.5 * scale, -0.15 * scale, 1.4 * scale], [0, -0.2 * scale, 1.5 * scale]], // Lv3: 5引擎
        [[-1.2 * scale, -0.1 * scale, 1.2 * scale], [1.2 * scale, -0.1 * scale, 1.2 * scale], [-0.6 * scale, -0.15 * scale, 1.4 * scale], [0.6 * scale, -0.15 * scale, 1.4 * scale], [-0.3 * scale, -0.2 * scale, 1.5 * scale], [0.3 * scale, -0.2 * scale, 1.5 * scale]], // Lv4: 6引擎
        [[-1.2 * scale, -0.1 * scale, 1.2 * scale], [1.2 * scale, -0.1 * scale, 1.2 * scale], [-0.6 * scale, -0.15 * scale, 1.4 * scale], [0.6 * scale, -0.15 * scale, 1.4 * scale], [-0.3 * scale, -0.2 * scale, 1.5 * scale], [0.3 * scale, -0.2 * scale, 1.5 * scale], [0, -0.25 * scale, 1.6 * scale]], // Lv5: 7引擎
    ];
    const positions = enginePositions[Math.min(level - 1, 4)];
    positions.forEach(pos => {
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.set(...pos);
        group.add(engine);
    });
    
    // 高等级添加装饰翼
    if (level >= 2) {
        const decoWingGeo = new THREE.BoxGeometry(1.5 * scale, 0.05 * scale, 0.6 * scale);
        const decoWingL = new THREE.Mesh(decoWingGeo, wingMat);
        decoWingL.position.set(-1.8 * scale, 0.1 * scale, 0.5 * scale);
        decoWingL.rotation.z = 0.4;
        group.add(decoWingL);
        
        const decoWingR = new THREE.Mesh(decoWingGeo, wingMat);
        decoWingR.position.set(1.8 * scale, 0.1 * scale, 0.5 * scale);
        decoWingR.rotation.z = -0.4;
        group.add(decoWingR);
    }
    
    // Lv3+ 添加顶部天线/雷达
    if (level >= 3) {
        const antennaGeo = new THREE.CylinderGeometry(0.05 * scale, 0.05 * scale, 0.8 * scale, 6);
        const antennaMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff,
            emissiveIntensity: 0.5
        });
        const antenna = new THREE.Mesh(antennaGeo, antennaMat);
        antenna.position.set(0, 0.8 * scale, 0);
        group.add(antenna);
        
        const radarGeo = new THREE.SphereGeometry(0.15 * scale, 8, 8);
        const radar = new THREE.Mesh(radarGeo, antennaMat);
        radar.position.set(0, 1.2 * scale, 0);
        group.add(radar);
    }
    
    // Lv4+ 添加侧翼武器挂架
    if (level >= 4) {
        const weaponGeo = new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 1.2 * scale, 6);
        const weaponMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const weaponL = new THREE.Mesh(weaponGeo, weaponMat);
        weaponL.position.set(-2.2 * scale, -0.2 * scale, 0.3 * scale);
        weaponL.rotation.x = Math.PI / 2;
        group.add(weaponL);
        
        const weaponR = new THREE.Mesh(weaponGeo, weaponMat);
        weaponR.position.set(2.2 * scale, -0.2 * scale, 0.3 * scale);
        weaponR.rotation.x = Math.PI / 2;
        group.add(weaponR);
    }
    
    // Lv5 添加光环装饰
    if (level >= 5) {
        const ringGeo = new THREE.TorusGeometry(1.5 * scale, 0.05 * scale, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({ 
            color: color.engine,
            emissive: color.engine,
            emissiveIntensity: 2
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(0, 0.3 * scale, -0.5 * scale);
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
    }
    
    return group;
}

// 创建敌机
function createEnemyShip(type) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: type === 'fast' ? 0xff6600 : type === 'heavy' ? 0x6622aa : 0xff3333, 
        metalness: 0.7, 
        roughness: 0.3 
    });
    
    if (type === 'fast') {
        const bodyGeo = new THREE.ConeGeometry(0.5, 2, 8);
        bodyGeo.rotateX(-Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        const wingGeo = new THREE.BoxGeometry(2.5, 0.08, 0.8);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, 0, 0.3);
        wing.rotation.x = 0.3;
        group.add(wing);
        const tailGeo = new THREE.BoxGeometry(0.08, 0.6, 0.4);
        const tailL = new THREE.Mesh(tailGeo, bodyMat);
        tailL.position.set(-0.4, 0.3, 0.8);
        tailL.rotation.z = -0.2;
        group.add(tailL);
        const tailR = new THREE.Mesh(tailGeo, bodyMat);
        tailR.position.set(0.4, 0.3, 0.8);
        tailR.rotation.z = 0.2;
        group.add(tailR);
        return { group, hp: 2, maxHp: 2, speed: 0.18, color: '#0f0' };
    } else if (type === 'heavy') {
        const bodyGeo = new THREE.CylinderGeometry(0.5, 0.6, 2, 8);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        const wingGeo = new THREE.BoxGeometry(3.5, 0.1, 1);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, -0.1, 0.2);
        group.add(wing);
        return { group, hp: 5, maxHp: 5, speed: 0.08, color: '#0f0' };
    } else {
        const bodyGeo = new THREE.CylinderGeometry(0.35, 0.45, 2, 8);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        const wingGeo = new THREE.BoxGeometry(2.8, 0.08, 0.9);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, -0.05, 0.2);
        wing.rotation.x = 0.15;
        group.add(wing);
        const hTailGeo = new THREE.BoxGeometry(1.2, 0.06, 0.4);
        const hTail = new THREE.Mesh(hTailGeo, bodyMat);
        hTail.position.set(0, 0.1, 1);
        group.add(hTail);
        const vTailGeo = new THREE.BoxGeometry(0.06, 0.6, 0.4);
        const vTail = new THREE.Mesh(vTailGeo, bodyMat);
        vTail.position.set(0, 0.4, 0.9);
        group.add(vTail);
        return { group, hp: 3, maxHp: 3, speed: 0.12, color: '#0f0' };
    }
}

// 创建BOSS - 超级加强版
function createBoss() {
    const group = new THREE.Group();
    
    // BOSS机身 - 增大50%
    const bodyGeo = new THREE.CylinderGeometry(1.8, 2.2, 7, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: 0xff0044, 
        metalness: 0.9, 
        roughness: 0.1,
        emissive: 0x440022
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    group.add(body);
    
    // BOSS主翼 - 超超大
    const mainWingGeo = new THREE.BoxGeometry(12, 0.3, 3.5);
    const wingMat = new THREE.MeshStandardMaterial({ 
        color: 0xcc0033, 
        metalness: 0.8, 
        roughness: 0.2 
    });
    const mainWing = new THREE.Mesh(mainWingGeo, wingMat);
    mainWing.position.set(0, 0, 0.5);
    group.add(mainWing);
    
    // BOSS副翼
    const subWingGeo = new THREE.BoxGeometry(6, 0.2, 2);
    const subWingL = new THREE.Mesh(subWingGeo, wingMat);
    subWingL.position.set(-3.5, 0.4, -0.5);
    subWingL.rotation.z = 0.3;
    group.add(subWingL);
    const subWingR = new THREE.Mesh(subWingGeo, wingMat);
    subWingR.position.set(3.5, 0.4, -0.5);
    subWingR.rotation.z = -0.3;
    group.add(subWingR);
    
    // BOSS尾翼
    const tailGeo = new THREE.BoxGeometry(0.4, 2, 1.5);
    const tailL = new THREE.Mesh(tailGeo, wingMat);
    tailL.position.set(-2, 1.2, 3);
    tailL.rotation.z = -0.3;
    group.add(tailL);
    const tailR = new THREE.Mesh(tailGeo, wingMat);
    tailR.position.set(2, 1.2, 3);
    tailR.rotation.z = 0.3;
    group.add(tailR);
    
    // BOSS核心 - 更大的发光球体
    const coreGeo = new THREE.SphereGeometry(1.2, 16, 16);
    const coreMat = new THREE.MeshBasicMaterial({ 
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 3
    });
    const core = new THREE.Mesh(coreGeo, coreMat);
    core.position.set(0, 0.8, 0);
    group.add(core);
    
    // BOSS引擎 - 更多更大
    const engineGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8);
    engineGeo.rotateX(Math.PI / 2);
    const engineMat = new THREE.MeshBasicMaterial({ 
        color: 0xff4400, 
        emissive: 0xff2200 
    });
    const positions = [[-3, -0.5, 3.5], [3, -0.5, 3.5], [-1.5, -0.5, 4], [1.5, -0.5, 4], [-0.5, -0.5, 4.5], [0.5, -0.5, 4.5]];
    positions.forEach(pos => {
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.set(...pos);
        group.add(engine);
    });
    
    // BOSS护甲装饰
    const armorGeo = new THREE.BoxGeometry(2, 0.5, 2);
    const armorMat = new THREE.MeshStandardMaterial({ 
        color: 0x880022, 
        metalness: 1, 
        roughness: 0.1 
    });
    for (let i = 0; i < 4; i++) {
        const armor = new THREE.Mesh(armorGeo, armorMat);
        armor.position.set(
            (i % 2 === 0 ? -1 : 1) * 2.5,
            0.5,
            -1 + Math.floor(i / 2) * 2
        );
        group.add(armor);
    }
    
    // 返回：适中的难度
    return { group, hp: 80, maxHp: 80, speed: 0.025, color: '#f00', isBoss: true };
}

// 初始化
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, -5);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000205);
    document.getElementById('game-container').appendChild(renderer.domElement);
    
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(10, 20, 10);
    scene.add(sunLight);
    const rimLight = new THREE.DirectionalLight(0x0088ff, 0.5);
    rimLight.position.set(-10, 5, -10);
    scene.add(rimLight);
    
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1500;
    const positions = new Float32Array(starCount * 3);
    for(let i = 0; i < starCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 150;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2});
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);
    
    player = createPlayerShip(playerLevel);
    player.position.set(0, 0, 5);
    scene.add(player);
    
    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// 发射子弹
function shoot() {
    const now = Date.now();
    if (now - lastShot < 120) return;
    lastShot = now;
    playShootSound();
    const geometry = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff });
    const bullet = new THREE.Mesh(geometry, material);
    bullet.position.copy(player.position);
    bullet.position.y = 0;
    bullet.position.z -= 1;
    scene.add(bullet);
    bullets.push(bullet);
}

// BOSS发射弹幕 - 加强版
function bossShoot(boss) {
    // BOSS发射5发扇形子弹（更密集的弹幕）
    const angles = [-0.5, -0.25, 0, 0.25, 0.5]; // 5个方向
    angles.forEach(angle => {
        const geometry = new THREE.SphereGeometry(0.3, 8, 8); // 更大的子弹
        const material = new THREE.MeshBasicMaterial({ color: 0xff0044, emissive: 0xff0022 });
        const bullet = new THREE.Mesh(geometry, material);
        bullet.position.copy(boss.mesh.position);
        bullet.position.y = 0;
        bullet.position.z += 3;
        
        // 更快的子弹速度
        bullet.userData.velocity = new THREE.Vector3(
            Math.sin(angle) * 0.4,
            0,
            0.8 + Math.cos(angle) * 0.3
        );
        
        scene.add(bullet);
        enemyBullets.push(bullet);
    });
}

// 生成敌机或BOSS
function spawnEnemy() {
    // 每5波生成一个BOSS
    const isBossWave = wave % 5 === 0;
    const existingBoss = enemies.some(e => e.isBoss);
    
    if (isBossWave && !existingBoss) {
        // 生成BOSS
        const bossData = createBoss();
        const boss = bossData.group;
        boss.position.set(0, 0, -40); // BOSS从中间出现
        scene.add(boss);
        
        // BOSS使用更长的血条
        const healthBar = createBossHealthBar(bossData.maxHp);
        boss.add(healthBar.sprite);
        
        enemies.push({ 
            mesh: boss, 
            type: 'boss', 
            speed: bossData.speed, 
            hp: bossData.hp, 
            maxHp: bossData.maxHp,
            healthBar: healthBar,
            isBoss: true,
            lastShot: Date.now(),
            shootInterval: 1000 // 更频繁的攻击（1秒一次）
        });
        
        // 显示BOSS警告
        showBossWarning();
        return;
    }
    
    // 普通敌机
    const types = ['normal', 'fast', 'heavy'];
    const type = types[Math.floor(Math.random() * types.length)];
    const enemyData = createEnemyShip(type);
    const enemy = enemyData.group;
    enemy.position.set((Math.random() - 0.5) * 14, 0, -35 - Math.random() * 10);
    let speed = enemyData.speed * (1 + wave * 0.04);
    scene.add(enemy);
    
    const healthBar = createHealthBar(enemyData.maxHp, enemyData.color);
    enemy.add(healthBar.sprite);
    
    const shootInterval = type === 'fast' ? 2000 : type === 'heavy' ? 3000 : 2500;
    
    enemies.push({ 
        mesh: enemy, 
        type, 
        speed, 
        hp: enemyData.hp, 
        maxHp: enemyData.maxHp,
        healthBar: healthBar,
        lastShot: Date.now(),
        shootInterval: shootInterval
    });
}

// 创建BOSS血条 - 更长更显眼
function createBossHealthBar(maxHp) {
    const canvas = document.createElement('canvas');
    canvas.width = 80; // BOSS血条更长
    canvas.height = 8; // 更粗
    const ctx = canvas.getContext('2d');
    
    function draw(hpPercent) {
        // 背景
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, 80, 8);
        
        // 边框 - 金色
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, 80, 8);
        
        // 血量 - 紫色到红色渐变
        const percent = Math.max(0, Math.min(1, hpPercent));
        const gradient = ctx.createLinearGradient(0, 0, 78, 0);
        if (percent > 0.5) {
            gradient.addColorStop(0, '#ff0066');
            gradient.addColorStop(1, '#ff4400');
        } else if (percent > 0.25) {
            gradient.addColorStop(0, '#ff4400');
            gradient.addColorStop(1, '#ff8800');
        } else {
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(1, '#ff0044');
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(2, 2, 76 * percent, 4);
    }
    
    draw(1);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(3, 0.3, 1); // BOSS血条更大
    sprite.position.y = 2.5; // 更高位置
    
    return { sprite, canvas, ctx, draw };
}

// 显示BOSS警告
function showBossWarning() {
    const warning = document.createElement('div');
    warning.style.cssText = `
        position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
        color: #ff0044; font-size: 48px; font-weight: bold;
        text-shadow: 0 0 20px #ff0044, 0 0 40px #ff0000;
        animation: blink 0.5s infinite; pointer-events: none; z-index: 100;
    `;
    warning.textContent = '⚠️ WARNING: BOSS APPROACHING ⚠️';
    document.body.appendChild(warning);
    
    setTimeout(() => {
        warning.remove();
    }, 3000);
}

// 创建爆炸
function createExplosion(position, color) {
    for (let i = 0; i < 8; i++) {
        const geo = new THREE.SphereGeometry(0.15, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(position);
        p.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.4
        );
        scene.add(p);
        particles.push(p);
    }
}

// 受伤
function takeDamage(amount) {
    health -= amount;
    if (health < 0) health = 0;
    document.getElementById('health-fill').style.width = health + '%';
    playHitSound();
    document.body.style.boxShadow = 'inset 0 0 100px #f00';
    setTimeout(() => document.body.style.boxShadow = 'none', 200);
    if (health <= 0) gameOver();
}

// 游戏结束
function gameOver() {
    isPlaying = false;
    document.getElementById('menu').style.display = 'flex';
    document.querySelector('#menu h1').textContent = '任务失败';
    document.querySelector('#menu p').innerHTML = '最终得分: ' + score + '<br>波次: ' + wave;
    document.querySelector('#menu button').textContent = '重新开始';
}

// 游戏主循环 - 完全重写，更安全
function update() {
    if (!isPlaying) return;
    frameCount++;
    
    // 玩家移动
    if (keys['KeyW'] || keys['ArrowUp']) player.position.z -= 0.18;
    if (keys['KeyS'] || keys['ArrowDown']) player.position.z += 0.18;
    if (keys['KeyA'] || keys['ArrowLeft']) player.position.x -= 0.18;
    if (keys['KeyD'] || keys['ArrowRight']) player.position.x += 0.18;
    player.position.x = Math.max(-10, Math.min(10, player.position.x));
    player.position.z = Math.max(-25, Math.min(8, player.position.z));
    const targetRotZ = (keys['KeyA'] ? 0.4 : 0) + (keys['KeyD'] ? -0.4 : 0);
    player.rotation.z += (targetRotZ - player.rotation.z) * 0.1;
    player.rotation.y = -player.rotation.z * 0.5;
    if (keys['Space']) shoot();
    
    // 更新玩家子弹
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.z -= 0.9;
        if (bullets[i].position.z < -50) {
            scene.remove(bullets[i]);
            bullets.splice(i, 1);
        }
    }
    
    // 生成敌机
    enemySpawnTimer++;
    const spawnRate = Math.max(60, 150 - wave * 3);
    if (enemySpawnTimer > spawnRate) {
        spawnEnemy();
        enemySpawnTimer = 0;
    }
    
    // 获取玩家碰撞盒（只计算一次）
    const playerBox = new THREE.Box3().setFromObject(player);
    const now = Date.now();
    
    // 更新敌机 - 使用反向循环安全删除
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        
        // 安全检查
        if (!e || !e.mesh) {
            enemies.splice(i, 1);
            continue;
        }
        
        // BOSS特殊行为
        if (e.isBoss) {
            // BOSS左右移动
            e.mesh.position.x = Math.sin(now * 0.001) * 3;
            // BOSS缓慢旋转展示
            e.mesh.rotation.y = Math.PI + Math.sin(now * 0.0005) * 0.2;
            // BOSS发射弹幕
            if (now - e.lastShot > e.shootInterval) {
                bossShoot(e);
                e.lastShot = now;
            }
        } else {
            // 普通敌机行为
            e.mesh.position.z += e.speed;
            e.mesh.rotation.set(0, Math.PI, 0);
        }
        
        // 更新血条
        if (e.healthBar && e.healthBar.draw) {
            try {
                e.healthBar.draw(e.hp / e.maxHp);
                if (e.healthBar.sprite && e.healthBar.sprite.material) {
                    e.healthBar.sprite.material.map.needsUpdate = true;
                }
            } catch(err) { console.log('Health bar error:', err); }
        }
        
        const enemyBox = new THREE.Box3().setFromObject(e.mesh);
        
        // 撞击检测
        if (playerBox.intersectsBox(enemyBox)) {
            takeDamage(20);
            createExplosion(e.mesh.position, 0xff0000);
            scene.remove(e.mesh);
            enemies.splice(i, 1);
            continue;
        }
        
        // 飞出屏幕
        if (e.mesh.position.z > 10) {
            scene.remove(e.mesh);
            enemies.splice(i, 1);
            continue;
        }
        
        // 子弹击中检测 - 增加伤害（2点）
        let hit = false;
        for (let j = bullets.length - 1; j >= 0; j--) {
            const bulletBox = new THREE.Box3().setFromObject(bullets[j]);
            if (bulletBox.intersectsBox(enemyBox)) {
                e.hp -= 2; // 一发子弹造成2点伤害
                scene.remove(bullets[j]);
                bullets.splice(j, 1);
                hit = true;
                
                if (e.hp <= 0) {
                    const color = e.type === 'fast' ? 0xff6600 : e.type === 'heavy' ? 0xff00ff : 0xff0000;
                    createExplosion(e.mesh.position, color);
                    playExplosionSound();
                    scene.remove(e.mesh);
                    enemies.splice(i, 1);
                    
                    const points = e.type === 'fast' ? 120 : e.type === 'heavy' ? 350 : 220;
                    score += points;
                    document.getElementById('score').textContent = 'SCORE: ' + score;
                    
                    if (score > wave * 1000) {
                        wave++;
                        document.getElementById('wave').textContent = 'WAVE: ' + wave;
                        
                        // 每5波玩家升级
                        if (wave % 5 === 1 && wave > 1) {
                            playerLevel++;
                            upgradePlayer();
                        }
                    }
                }
                break;
            }
        }
        if (hit) continue;
    }
    
    // 更新敌机子弹（包括BOSS弹幕）
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        if (b.userData.velocity) {
            b.position.add(b.userData.velocity);
        } else {
            b.position.z += 0.5;
        }
        
        // 检测击中玩家（BOSS子弹伤害更高）
        const bulletBox = new THREE.Box3().setFromObject(b);
        if (bulletBox.intersectsBox(playerBox)) {
            // 根据子弹大小判断是否为BOSS子弹
            const isBossBullet = b.geometry.parameters.radius > 0.25;
            takeDamage(isBossBullet ? 20 : 15);
            scene.remove(b);
            enemyBullets.splice(i, 1);
            continue;
        }
        
        // 飞出屏幕
        if (b.position.z > 15) {
            scene.remove(b);
            enemyBullets.splice(i, 1);
        }
    }
    
    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (p.userData.velocity) {
            p.position.add(p.userData.velocity);
        }
        p.scale.multiplyScalar(0.96);
        if (p.scale.x < 0.01) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(update);
}

// 玩家升级
function upgradePlayer() {
    // 保存当前位置
    const currentPos = player.position.clone();
    
    // 移除旧飞船
    scene.remove(player);
    
    // 创建新等级飞船
    player = createPlayerShip(playerLevel);
    player.position.copy(currentPos);
    scene.add(player);
    
    // 更新UI
    document.getElementById('level').textContent = 'LV: ' + playerLevel;
    
    // 显示升级提示
    showUpgradeMessage();
    
    // 升级奖励：恢复血量
    health = Math.min(100, health + 30);
    document.getElementById('health-fill').style.width = health + '%';
}

// 显示升级提示
function showUpgradeMessage() {
    const msg = document.createElement('div');
    msg.style.cssText = `
        position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
        color: #00ff00; font-size: 48px; font-weight: bold;
        text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
        animation: pulse 0.5s infinite; pointer-events: none; z-index: 100;
    `;
    const colors = ['蓝色', '绿色', '橙色', '粉色', '紫色'];
    const colorName = colors[(playerLevel - 1) % colors.length];
    msg.textContent = `⭐ LEVEL UP! ⭐\nLv.${playerLevel} ${colorName}战机`;
    msg.style.whiteSpace = 'pre-line';
    msg.style.textAlign = 'center';
    document.body.appendChild(msg);
    
    setTimeout(() => {
        msg.remove();
    }, 3000);
}

// 开始游戏
function startGame() {
    initAudio();
    document.getElementById('menu').style.display = 'none';
    
    // 重置所有状态
    score = 0;
    wave = 1;
    health = 100;
    playerLevel = 1;
    frameCount = 0;
    enemySpawnTimer = 0;
    lastShot = 0;
    
    document.getElementById('score').textContent = 'SCORE: 0';
    document.getElementById('wave').textContent = 'WAVE: 1';
    document.getElementById('level').textContent = 'LV: 1';
    document.getElementById('health-fill').style.width = '100%';
    
    // 清理所有对象
    enemies.forEach(e => { if (e.mesh) scene.remove(e.mesh); });
    enemies = [];
    bullets.forEach(b => scene.remove(b));
    bullets = [];
    enemyBullets.forEach(b => scene.remove(b));
    enemyBullets = [];
    particles.forEach(p => scene.remove(p));
    particles = [];
    
    player.position.set(0, 0, 5);
    player.rotation.set(0, 0, 0);
    
    isPlaying = true;
    update();
}

// 初始化
init();
renderer.render(scene, camera);
</script>
</body>
</html>