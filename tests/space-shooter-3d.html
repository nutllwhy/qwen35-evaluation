<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 太空射击 - 战斗机版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        #game-container { width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; padding: 15px 20px; color: #0ff; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #0ff; background: rgba(0,20,40,0.6); border: 2px solid #0ff; border-radius: 10px; }
        #score { top: 20px; left: 20px; }
        #wave { top: 20px; left: 260px; color: #ff0; border-color: #ff0; text-shadow: 0 0 10px #ff0; }
        #health { top: 20px; right: 20px; width: 180px; }
        .health-bar { width: 100%; height: 18px; background: rgba(0,0,0,0.5); border: 2px solid #0ff; border-radius: 9px; overflow: hidden; margin-top: 8px; }
        .health-fill { height: 100%; background: linear-gradient(90deg, #f00, #0f0); width: 100%; transition: width 0.3s; }
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(0,50,100,0.8) 0%, rgba(0,0,0,0.95) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #menu h1 { color: #0ff; font-size: 56px; margin-bottom: 20px; text-shadow: 0 0 30px #0ff; letter-spacing: 8px; }
        #menu p { color: #aaa; margin-bottom: 30px; text-align: center; font-size: 16px; }
        #menu button { padding: 18px 50px; font-size: 26px; background: linear-gradient(45deg, #00aaff, #0066ff); color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 30px rgba(0,170,255,0.6); transition: all 0.3s; }
        #menu button:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(0,170,255,0.9); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui">
        <div class="hud" id="score">SCORE: 0</div>
        <div class="hud" id="wave">WAVE: 1</div>
        <div class="hud" id="health">
            SHIELD
            <div class="health-bar">
                <div class="health-fill" id="health-fill"></div>
            </div>
        </div>
    </div>
    <div id="menu">
        <h1>STAR FIGHTER</h1>
        <p>WASD 移动 | 空格 射击<br>敌机更像真实的战斗机！血条缩短，节奏更舒适</p>
        <button onclick="startGame()">开始游戏</button>
    </div>

<script>
let scene, camera, renderer, player;
let bullets = [], enemies = [], particles = [];
let score = 0, wave = 1, health = 100;
let isPlaying = false, keys = {}, lastShot = 0;
let audioCtx;

function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playShootSound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}
function playExplosionSound() {
    if (!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.3;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1000;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    noise.start();
}
function playHitSound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.3);
}

// 创建短血条 - 缩短长度
function createHealthBar(maxHp, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 40; // 缩短宽度
    canvas.height = 6; // 缩短高度
    const ctx = canvas.getContext('2d');
    
    function draw(hpPercent) {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, 40, 6);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, 40, 6);
        
        const percent = Math.max(0, hpPercent);
        ctx.fillStyle = percent > 0.5 ? color : percent > 0.25 ? '#ff0' : '#f00';
        ctx.fillRect(1, 1, 38 * percent, 4);
    }
    
    draw(1);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(1.2, 0.18, 1); // 缩小比例
    sprite.position.y = 1.2;
    
    return { sprite, canvas, ctx, draw };
}

// 创建玩家飞船
function createPlayerShip() {
    const group = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(0.3, 0.5, 2.5, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4488ff, metalness: 0.8, roughness: 0.2 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    group.add(body);
    const cockpitGeo = new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const cockpitMat = new THREE.MeshPhysicalMaterial({ color: 0x00ffff, transmission: 0.9, transparent: true, opacity: 0.6 });
    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
    cockpit.position.set(0, 0.4, 0.3);
    group.add(cockpit);
    const wingGeo = new THREE.BoxGeometry(3, 0.1, 1.2);
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x3366cc, metalness: 0.8, roughness: 0.2 });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(0, -0.1, 0.3);
    wing.rotation.x = 0.2;
    group.add(wing);
    const tailGeo = new THREE.BoxGeometry(0.1, 0.8, 0.6);
    const tail = new THREE.Mesh(tailGeo, wingMat);
    tail.position.set(0, 0.4, 1);
    tail.rotation.x = 0.3;
    group.add(tail);
    const engineGeo = new THREE.CylinderGeometry(0.2, 0.35, 0.8, 8);
    engineGeo.rotateX(Math.PI / 2);
    const engineMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, emissive: 0x00ffff });
    const engineL = new THREE.Mesh(engineGeo, engineMat);
    engineL.position.set(-0.6, -0.1, 1.2);
    group.add(engineL);
    const engineR = new THREE.Mesh(engineGeo, engineMat);
    engineR.position.set(0.6, -0.1, 1.2);
    group.add(engineR);
    return group;
}

// 创建更像战斗机的敌机
function createEnemyShip(type) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: type === 'fast' ? 0xff6600 : type === 'heavy' ? 0x6622aa : 0xff3333, 
        metalness: 0.7, 
        roughness: 0.3 
    });
    
    if (type === 'fast') {
        // 快速战斗机 - 流线型
        // 尖锐机身
        const bodyGeo = new THREE.ConeGeometry(0.5, 2, 8);
        bodyGeo.rotateX(-Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        // 后掠翼
        const wingGeo = new THREE.BoxGeometry(2.5, 0.08, 0.8);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, 0, 0.3);
        wing.rotation.x = 0.3; // 后掠
        group.add(wing);
        // 双垂尾
        const tailGeo = new THREE.BoxGeometry(0.08, 0.6, 0.4);
        const tailL = new THREE.Mesh(tailGeo, bodyMat);
        tailL.position.set(-0.4, 0.3, 0.8);
        tailL.rotation.z = -0.2;
        group.add(tailL);
        const tailR = new THREE.Mesh(tailGeo, bodyMat);
        tailR.position.set(0.4, 0.3, 0.8);
        tailR.rotation.z = 0.2;
        group.add(tailR);
        return { group, hp: 4, maxHp: 4, speed: 0.18, color: '#0f0' };
        
    } else if (type === 'heavy') {
        // 重型轰炸机 - 宽大机身
        // 宽机身
        const bodyGeo = new THREE.CylinderGeometry(0.5, 0.6, 2, 8);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        // 大展弦比机翼
        const wingGeo = new THREE.BoxGeometry(3.5, 0.1, 1);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, -0.1, 0.2);
        group.add(wing);
        // 四引擎
        const engineGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.5, 6);
        engineGeo.rotateX(Math.PI / 2);
        const engineMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
        const positions = [[-1.2, -0.2, 0.8], [1.2, -0.2, 0.8], [-0.6, -0.2, 0.9], [0.6, -0.2, 0.9]];
        positions.forEach(pos => {
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.set(...pos);
            group.add(engine);
        });
        return { group, hp: 10, maxHp: 10, speed: 0.08, color: '#0f0' };
        
    } else {
        // 标准战斗机 - 经典布局
        // 机身
        const bodyGeo = new THREE.CylinderGeometry(0.35, 0.45, 2, 8);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        // 主机翼
        const wingGeo = new THREE.BoxGeometry(2.8, 0.08, 0.9);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, -0.05, 0.2);
        wing.rotation.x = 0.15;
        group.add(wing);
        // 水平尾翼
        const hTailGeo = new THREE.BoxGeometry(1.2, 0.06, 0.4);
        const hTail = new THREE.Mesh(hTailGeo, bodyMat);
        hTail.position.set(0, 0.1, 1);
        group.add(hTail);
        // 垂直尾翼
        const vTailGeo = new THREE.BoxGeometry(0.06, 0.6, 0.4);
        const vTail = new THREE.Mesh(vTailGeo, bodyMat);
        vTail.position.set(0, 0.4, 0.9);
        group.add(vTail);
        // 进气口
        const intakeGeo = new THREE.BoxGeometry(0.3, 0.2, 0.5);
        const intakeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const intakeL = new THREE.Mesh(intakeGeo, intakeMat);
        intakeL.position.set(-0.5, -0.1, 0.3);
        group.add(intakeL);
        const intakeR = new THREE.Mesh(intakeGeo, intakeMat);
        intakeR.position.set(0.5, -0.1, 0.3);
        group.add(intakeR);
        return { group, hp: 6, maxHp: 6, speed: 0.12, color: '#0f0' };
    }
}

// 初始化
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, -5);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000205);
    document.getElementById('game-container').appendChild(renderer.domElement);
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(10, 20, 10);
    scene.add(sunLight);
    const rimLight = new THREE.DirectionalLight(0x0088ff, 0.5);
    rimLight.position.set(-10, 5, -10);
    scene.add(rimLight);
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1500;
    const positions = new Float32Array(starCount * 3);
    for(let i = 0; i < starCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 150;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2});
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);
    player = createPlayerShip();
    player.position.set(0, 0, 5);
    scene.add(player);
    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// 发射子弹
function shoot() {
    const now = Date.now();
    if (now - lastShot < 120) return;
    lastShot = now;
    playShootSound();
    const geometry = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff });
    const bullet = new THREE.Mesh(geometry, material);
    bullet.position.copy(player.position);
    bullet.position.y = 0;
    bullet.position.z -= 1;
    scene.add(bullet);
    bullets.push(bullet);
}

// 生成敌机 - 降低频率
let enemySpawnTimer = 0;
function spawnEnemy() {
    const types = ['normal', 'fast', 'heavy'];
    const type = types[Math.floor(Math.random() * types.length)];
    const enemyData = createEnemyShip(type);
    const enemy = enemyData.group;
    enemy.position.set((Math.random() - 0.5) * 14, 0, -35 - Math.random() * 10);
    let speed = enemyData.speed * (1 + wave * 0.04);
    scene.add(enemy);
    
    // 创建血条
    const healthBar = createHealthBar(enemyData.maxHp, enemyData.color);
    enemy.add(healthBar.sprite);
    
    enemies.push({ 
        mesh: enemy, 
        type, 
        speed, 
        hp: enemyData.hp, 
        maxHp: enemyData.maxHp,
        healthBar: healthBar
    });
}

// 创建爆炸
function createExplosion(position, color) {
    for (let i = 0; i < 10; i++) {
        const geo = new THREE.SphereGeometry(0.18, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(position);
        p.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5
        );
        scene.add(p);
        particles.push(p);
    }
}

// 受伤
function takeDamage(amount) {
    health -= amount;
    if (health < 0) health = 0;
    document.getElementById('health-fill').style.width = health + '%';
    playHitSound();
    document.body.style.boxShadow = 'inset 0 0 100px #f00';
    setTimeout(() => document.body.style.boxShadow = 'none', 200);
    if (health <= 0) gameOver();
}

// 游戏结束
function gameOver() {
    isPlaying = false;
    document.getElementById('menu').style.display = 'flex';
    document.querySelector('#menu h1').textContent = '任务失败';
    document.querySelector('#menu p').innerHTML = '最终得分: ' + score + '<br>波次: ' + wave;
    document.querySelector('#menu button').textContent = '重新开始';
}

// 游戏主循环
function update() {
    if (!isPlaying) return;
    
    // 玩家移动
    if (keys['KeyW'] || keys['ArrowUp']) player.position.z -= 0.18;
    if (keys['KeyS'] || keys['ArrowDown']) player.position.z += 0.18;
    if (keys['KeyA'] || keys['ArrowLeft']) player.position.x -= 0.18;
    if (keys['KeyD'] || keys['ArrowRight']) player.position.x += 0.18;
    player.position.x = Math.max(-10, Math.min(10, player.position.x));
    player.position.z = Math.max(-25, Math.min(8, player.position.z));
    const targetRotZ = (keys['KeyA'] ? 0.4 : 0) + (keys['KeyD'] ? -0.4 : 0);
    player.rotation.z += (targetRotZ - player.rotation.z) * 0.1;
    player.rotation.y = -player.rotation.z * 0.5;
    if (keys['Space']) shoot();
    
    // 更新子弹
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.z -= 0.9;
        if (bullets[i].position.z < -50) {
            scene.remove(bullets[i]);
            bullets.splice(i, 1);
        }
    }
    
    // 生成敌机 - 显著降低频率
    enemySpawnTimer++;
    const spawnRate = Math.max(60, 150 - wave * 3); // 原来40-120，现在60-150
    if (enemySpawnTimer > spawnRate) {
        spawnEnemy();
        enemySpawnTimer = 0;
    }
    
    // 碰撞检测
    const playerBox = new THREE.Box3().setFromObject(player);
    const enemiesToRemove = [];
    const bulletsToRemove = [];
    
    for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        e.mesh.position.z += e.speed;
        e.mesh.rotation.y += 0.02;
        
        // 更新血条
        if (e.healthBar) {
            e.healthBar.draw(e.hp / e.maxHp);
            e.healthBar.sprite.material.map.needsUpdate = true;
        }
        
        const enemyBox = new THREE.Box3().setFromObject(e.mesh);
        
        // 撞击玩家
        if (playerBox.intersectsBox(enemyBox)) {
            takeDamage(20);
            createExplosion(e.mesh.position, 0xff0000);
            enemiesToRemove.push(i);
            continue;
        }
        
        // 飞出屏幕
        if (e.mesh.position.z > 10) {
            enemiesToRemove.push(i);
            continue;
        }
        
        // 子弹击中
        for (let j = 0; j < bullets.length; j++) {
            if (bulletsToRemove.indexOf(j) !== -1) continue;
            const bulletBox = new THREE.Box3().setFromObject(bullets[j]);
            if (bulletBox.intersectsBox(enemyBox)) {
                e.hp--;
                bulletsToRemove.push(j);
                
                // 命中闪烁
                e.mesh.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.emissive = new THREE.Color(0xffffff);
                        setTimeout(() => {
                            if (child.material) child.material.emissive = new THREE.Color(0x000000);
                        }, 60);
                    }
                });
                
                if (e.hp <= 0) {
                    const color = e.type === 'fast' ? 0xff6600 : e.type === 'heavy' ? 0xff00ff : 0xff0000;
                    createExplosion(e.mesh.position, color);
                    playExplosionSound();
                    enemiesToRemove.push(i);
                    
                    const points = e.type === 'fast' ? 120 : e.type === 'heavy' ? 350 : 220;
                    score += points;
                    document.getElementById('score').textContent = 'SCORE: ' + score;
                    
                    if (score > wave * 1000) {
                        wave++;
                        document.getElementById('wave').textContent = 'WAVE: ' + wave;
                    }
                }
                break;
            }
        }
    }
    
    // 安全删除
    enemiesToRemove.sort((a, b) => b - a);
    for (const idx of enemiesToRemove) {
        if (enemies[idx]) {
            scene.remove(enemies[idx].mesh);
            enemies.splice(idx, 1);
        }
    }
    bulletsToRemove.sort((a, b) => b - a);
    for (const idx of bulletsToRemove) {
        if (bullets[idx]) {
            scene.remove(bullets[idx]);
            bullets.splice(idx, 1);
        }
    }
    
    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (p.userData.velocity) {
            p.position.add(p.userData.velocity);
        }
        p.scale.multiplyScalar(0.96);
        if (p.scale.x < 0.01) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(update);
}

// 开始游戏
function startGame() {
    initAudio();
    document.getElementById('menu').style.display = 'none';
    score = 0;
    wave = 1;
    health = 100;
    document.getElementById('score').textContent = 'SCORE: 0';
    document.getElementById('wave').textContent = 'WAVE: 1';
    document.getElementById('health-fill').style.width = '100%';
    enemies.forEach(e => scene.remove(e.mesh));
    enemies = [];
    bullets.forEach(b => scene.remove(b));
    bullets = [];
    particles.forEach(p => scene.remove(p));
    particles = [];
    player.position.set(0, 0, 5);
    player.rotation.set(0, 0, 0);
    isPlaying = true;
    update();
}

// 初始化
init();
renderer.render(scene, camera);
</script>
</body>
</html>