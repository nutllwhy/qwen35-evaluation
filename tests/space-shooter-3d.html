<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 太空射击 - 修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        #game-container { width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; padding: 15px 20px; color: #0ff; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px #0ff; background: rgba(0,20,40,0.6); border: 2px solid #0ff; border-radius: 10px; }
        #score { top: 20px; left: 20px; }
        #wave { top: 20px; left: 260px; color: #ff0; border-color: #ff0; text-shadow: 0 0 10px #ff0; }
        #health { top: 20px; right: 20px; width: 180px; }
        #version { 
            position: absolute; 
            bottom: 10px; 
            right: 20px; 
            color: #0ff; 
            font-size: 12px; 
            opacity: 0.7;
            text-shadow: 0 0 5px #0ff;
        }
        .health-bar { width: 100%; height: 18px; background: rgba(0,0,0,0.5); border: 2px solid #0ff; border-radius: 9px; overflow: hidden; margin-top: 8px; }
        .health-fill { height: 100%; background: linear-gradient(90deg, #f00, #0f0); width: 100%; transition: width 0.3s; }
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(0,50,100,0.8) 0%, rgba(0,0,0,0.95) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #menu h1 { color: #0ff; font-size: 56px; margin-bottom: 20px; text-shadow: 0 0 30px #0ff; letter-spacing: 8px; }
        #menu p { color: #aaa; margin-bottom: 30px; text-align: center; font-size: 16px; }
        #menu button { padding: 18px 50px; font-size: 26px; background: linear-gradient(45deg, #00aaff, #0066ff); color: white; border: none; border-radius: 50px; cursor: pointer; box-shadow: 0 0 30px rgba(0,170,255,0.6); transition: all 0.3s; }
        #menu button:hover { transform: scale(1.1); box-shadow: 0 0 50px rgba(0,170,255,0.9); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui">
        <div class="hud" id="score">SCORE: 0</div>
        <div class="hud" id="wave">WAVE: 1</div>
        <div class="hud" id="health">
            SHIELD
            <div class="health-bar">
                <div class="health-fill" id="health-fill"></div>
            </div>
        </div>
        <div id="version">v1.6.0 - Super BOSS</div>
    </div>
    <div id="menu">
        <h1>STAR FIGHTER</h1>
        <p>WASD 移动 | 空格 射击<br>修复版：更稳定的游戏体验</p>
        <button onclick="startGame()">开始游戏</button>
    </div>

<script>
// 游戏变量 - 使用更安全的数据结构
let scene, camera, renderer, player;
let bullets = [];
let enemies = [];
let particles = [];
let enemyBullets = [];
let score = 0, wave = 1, health = 100;
let isPlaying = false;
let keys = {};
let lastShot = 0;
let audioCtx;
let enemySpawnTimer = 0;
let frameCount = 0;

// 音效
function initAudio() { 
    audioCtx = new (window.AudioContext || window.webkitAudioContext)(); 
}

function playShootSound() {
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } catch(e) { console.log('Sound error:', e); }
}

function playExplosionSound() {
    if (!audioCtx) return;
    try {
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    } catch(e) { console.log('Sound error:', e); }
}

function playHitSound() {
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    } catch(e) { console.log('Sound error:', e); }
}

// 创建更短的血条
function createHealthBar(maxHp, color) {
    const canvas = document.createElement('canvas');
    canvas.width = 32; // 更短
    canvas.height = 4; // 更矮
    const ctx = canvas.getContext('2d');
    
    function draw(hpPercent) {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, 32, 4);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, 32, 4);
        
        const percent = Math.max(0, Math.min(1, hpPercent));
        ctx.fillStyle = percent > 0.5 ? color : percent > 0.25 ? '#ff0' : '#f00';
        ctx.fillRect(1, 1, 30 * percent, 2);
    }
    
    draw(1);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(0.8, 0.1, 1); // 缩小显示
    sprite.position.y = 1.0; // 降低位置
    
    return { sprite, canvas, ctx, draw };
}

// 创建玩家飞船
function createPlayerShip() {
    const group = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(0.3, 0.5, 2.5, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4488ff, metalness: 0.8, roughness: 0.2 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    group.add(body);
    const cockpitGeo = new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const cockpitMat = new THREE.MeshPhysicalMaterial({ color: 0x00ffff, transmission: 0.9, transparent: true, opacity: 0.6 });
    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
    cockpit.position.set(0, 0.4, 0.3);
    group.add(cockpit);
    const wingGeo = new THREE.BoxGeometry(3, 0.1, 1.2);
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x3366cc, metalness: 0.8, roughness: 0.2 });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(0, -0.1, 0.3);
    wing.rotation.x = 0.2;
    group.add(wing);
    const tailGeo = new THREE.BoxGeometry(0.1, 0.8, 0.6);
    const tail = new THREE.Mesh(tailGeo, wingMat);
    tail.position.set(0, 0.4, 1);
    tail.rotation.x = 0.3;
    group.add(tail);
    const engineGeo = new THREE.CylinderGeometry(0.2, 0.35, 0.8, 8);
    engineGeo.rotateX(Math.PI / 2);
    const engineMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, emissive: 0x00ffff });
    const engineL = new THREE.Mesh(engineGeo, engineMat);
    engineL.position.set(-0.6, -0.1, 1.2);
    group.add(engineL);
    const engineR = new THREE.Mesh(engineGeo, engineMat);
    engineR.position.set(0.6, -0.1, 1.2);
    group.add(engineR);
    return group;
}

// 创建敌机
function createEnemyShip(type) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: type === 'fast' ? 0xff6600 : type === 'heavy' ? 0x6622aa : 0xff3333, 
        metalness: 0.7, 
        roughness: 0.3 
    });
    
    if (type === 'fast') {
        const bodyGeo = new THREE.ConeGeometry(0.5, 2, 8);
        bodyGeo.rotateX(-Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        const wingGeo = new THREE.BoxGeometry(2.5, 0.08, 0.8);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, 0, 0.3);
        wing.rotation.x = 0.3;
        group.add(wing);
        const tailGeo = new THREE.BoxGeometry(0.08, 0.6, 0.4);
        const tailL = new THREE.Mesh(tailGeo, bodyMat);
        tailL.position.set(-0.4, 0.3, 0.8);
        tailL.rotation.z = -0.2;
        group.add(tailL);
        const tailR = new THREE.Mesh(tailGeo, bodyMat);
        tailR.position.set(0.4, 0.3, 0.8);
        tailR.rotation.z = 0.2;
        group.add(tailR);
        return { group, hp: 2, maxHp: 2, speed: 0.18, color: '#0f0' };
    } else if (type === 'heavy') {
        const bodyGeo = new THREE.CylinderGeometry(0.5, 0.6, 2, 8);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        const wingGeo = new THREE.BoxGeometry(3.5, 0.1, 1);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, -0.1, 0.2);
        group.add(wing);
        return { group, hp: 5, maxHp: 5, speed: 0.08, color: '#0f0' };
    } else {
        const bodyGeo = new THREE.CylinderGeometry(0.35, 0.45, 2, 8);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        const wingGeo = new THREE.BoxGeometry(2.8, 0.08, 0.9);
        const wing = new THREE.Mesh(wingGeo, bodyMat);
        wing.position.set(0, -0.05, 0.2);
        wing.rotation.x = 0.15;
        group.add(wing);
        const hTailGeo = new THREE.BoxGeometry(1.2, 0.06, 0.4);
        const hTail = new THREE.Mesh(hTailGeo, bodyMat);
        hTail.position.set(0, 0.1, 1);
        group.add(hTail);
        const vTailGeo = new THREE.BoxGeometry(0.06, 0.6, 0.4);
        const vTail = new THREE.Mesh(vTailGeo, bodyMat);
        vTail.position.set(0, 0.4, 0.9);
        group.add(vTail);
        return { group, hp: 3, maxHp: 3, speed: 0.12, color: '#0f0' };
    }
}

// 创建BOSS - 超级加强版
function createBoss() {
    const group = new THREE.Group();
    
    // BOSS机身 - 增大50%
    const bodyGeo = new THREE.CylinderGeometry(1.8, 2.2, 7, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: 0xff0044, 
        metalness: 0.9, 
        roughness: 0.1,
        emissive: 0x440022
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    group.add(body);
    
    // BOSS主翼 - 超超大
    const mainWingGeo = new THREE.BoxGeometry(12, 0.3, 3.5);
    const wingMat = new THREE.MeshStandardMaterial({ 
        color: 0xcc0033, 
        metalness: 0.8, 
        roughness: 0.2 
    });
    const mainWing = new THREE.Mesh(mainWingGeo, wingMat);
    mainWing.position.set(0, 0, 0.5);
    group.add(mainWing);
    
    // BOSS副翼
    const subWingGeo = new THREE.BoxGeometry(6, 0.2, 2);
    const subWingL = new THREE.Mesh(subWingGeo, wingMat);
    subWingL.position.set(-3.5, 0.4, -0.5);
    subWingL.rotation.z = 0.3;
    group.add(subWingL);
    const subWingR = new THREE.Mesh(subWingGeo, wingMat);
    subWingR.position.set(3.5, 0.4, -0.5);
    subWingR.rotation.z = -0.3;
    group.add(subWingR);
    
    // BOSS尾翼
    const tailGeo = new THREE.BoxGeometry(0.4, 2, 1.5);
    const tailL = new THREE.Mesh(tailGeo, wingMat);
    tailL.position.set(-2, 1.2, 3);
    tailL.rotation.z = -0.3;
    group.add(tailL);
    const tailR = new THREE.Mesh(tailGeo, wingMat);
    tailR.position.set(2, 1.2, 3);
    tailR.rotation.z = 0.3;
    group.add(tailR);
    
    // BOSS核心 - 更大的发光球体
    const coreGeo = new THREE.SphereGeometry(1.2, 16, 16);
    const coreMat = new THREE.MeshBasicMaterial({ 
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 3
    });
    const core = new THREE.Mesh(coreGeo, coreMat);
    core.position.set(0, 0.8, 0);
    group.add(core);
    
    // BOSS引擎 - 更多更大
    const engineGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8);
    engineGeo.rotateX(Math.PI / 2);
    const engineMat = new THREE.MeshBasicMaterial({ 
        color: 0xff4400, 
        emissive: 0xff2200 
    });
    const positions = [[-3, -0.5, 3.5], [3, -0.5, 3.5], [-1.5, -0.5, 4], [1.5, -0.5, 4], [-0.5, -0.5, 4.5], [0.5, -0.5, 4.5]];
    positions.forEach(pos => {
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.set(...pos);
        group.add(engine);
    });
    
    // BOSS护甲装饰
    const armorGeo = new THREE.BoxGeometry(2, 0.5, 2);
    const armorMat = new THREE.MeshStandardMaterial({ 
        color: 0x880022, 
        metalness: 1, 
        roughness: 0.1 
    });
    for (let i = 0; i < 4; i++) {
        const armor = new THREE.Mesh(armorGeo, armorMat);
        armor.position.set(
            (i % 2 === 0 ? -1 : 1) * 2.5,
            0.5,
            -1 + Math.floor(i / 2) * 2
        );
        group.add(armor);
    }
    
    // 返回：HP从50增加到120，速度更慢（0.015）
    return { group, hp: 120, maxHp: 120, speed: 0.015, color: '#f00', isBoss: true };
}

// 初始化
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, -5);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000205);
    document.getElementById('game-container').appendChild(renderer.domElement);
    
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(10, 20, 10);
    scene.add(sunLight);
    const rimLight = new THREE.DirectionalLight(0x0088ff, 0.5);
    rimLight.position.set(-10, 5, -10);
    scene.add(rimLight);
    
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1500;
    const positions = new Float32Array(starCount * 3);
    for(let i = 0; i < starCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 150;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2});
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);
    
    player = createPlayerShip();
    player.position.set(0, 0, 5);
    scene.add(player);
    
    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// 发射子弹
function shoot() {
    const now = Date.now();
    if (now - lastShot < 120) return;
    lastShot = now;
    playShootSound();
    const geometry = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff });
    const bullet = new THREE.Mesh(geometry, material);
    bullet.position.copy(player.position);
    bullet.position.y = 0;
    bullet.position.z -= 1;
    scene.add(bullet);
    bullets.push(bullet);
}

// BOSS发射弹幕 - 加强版
function bossShoot(boss) {
    // BOSS发射5发扇形子弹（更密集的弹幕）
    const angles = [-0.5, -0.25, 0, 0.25, 0.5]; // 5个方向
    angles.forEach(angle => {
        const geometry = new THREE.SphereGeometry(0.3, 8, 8); // 更大的子弹
        const material = new THREE.MeshBasicMaterial({ color: 0xff0044, emissive: 0xff0022 });
        const bullet = new THREE.Mesh(geometry, material);
        bullet.position.copy(boss.mesh.position);
        bullet.position.y = 0;
        bullet.position.z += 3;
        
        // 更快的子弹速度
        bullet.userData.velocity = new THREE.Vector3(
            Math.sin(angle) * 0.4,
            0,
            0.8 + Math.cos(angle) * 0.3
        );
        
        scene.add(bullet);
        enemyBullets.push(bullet);
    });
}

// 生成敌机或BOSS
function spawnEnemy() {
    // 每5波生成一个BOSS
    const isBossWave = wave % 5 === 0;
    const existingBoss = enemies.some(e => e.isBoss);
    
    if (isBossWave && !existingBoss) {
        // 生成BOSS
        const bossData = createBoss();
        const boss = bossData.group;
        boss.position.set(0, 0, -40); // BOSS从中间出现
        scene.add(boss);
        
        // BOSS使用更长的血条
        const healthBar = createBossHealthBar(bossData.maxHp);
        boss.add(healthBar.sprite);
        
        enemies.push({ 
            mesh: boss, 
            type: 'boss', 
            speed: bossData.speed, 
            hp: bossData.hp, 
            maxHp: bossData.maxHp,
            healthBar: healthBar,
            isBoss: true,
            lastShot: Date.now(),
            shootInterval: 1000 // 更频繁的攻击（1秒一次）
        });
        
        // 显示BOSS警告
        showBossWarning();
        return;
    }
    
    // 普通敌机
    const types = ['normal', 'fast', 'heavy'];
    const type = types[Math.floor(Math.random() * types.length)];
    const enemyData = createEnemyShip(type);
    const enemy = enemyData.group;
    enemy.position.set((Math.random() - 0.5) * 14, 0, -35 - Math.random() * 10);
    let speed = enemyData.speed * (1 + wave * 0.04);
    scene.add(enemy);
    
    const healthBar = createHealthBar(enemyData.maxHp, enemyData.color);
    enemy.add(healthBar.sprite);
    
    const shootInterval = type === 'fast' ? 2000 : type === 'heavy' ? 3000 : 2500;
    
    enemies.push({ 
        mesh: enemy, 
        type, 
        speed, 
        hp: enemyData.hp, 
        maxHp: enemyData.maxHp,
        healthBar: healthBar,
        lastShot: Date.now(),
        shootInterval: shootInterval
    });
}

// 创建BOSS血条 - 更长更显眼
function createBossHealthBar(maxHp) {
    const canvas = document.createElement('canvas');
    canvas.width = 80; // BOSS血条更长
    canvas.height = 8; // 更粗
    const ctx = canvas.getContext('2d');
    
    function draw(hpPercent) {
        // 背景
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, 80, 8);
        
        // 边框 - 金色
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, 80, 8);
        
        // 血量 - 紫色到红色渐变
        const percent = Math.max(0, Math.min(1, hpPercent));
        const gradient = ctx.createLinearGradient(0, 0, 78, 0);
        if (percent > 0.5) {
            gradient.addColorStop(0, '#ff0066');
            gradient.addColorStop(1, '#ff4400');
        } else if (percent > 0.25) {
            gradient.addColorStop(0, '#ff4400');
            gradient.addColorStop(1, '#ff8800');
        } else {
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(1, '#ff0044');
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(2, 2, 76 * percent, 4);
    }
    
    draw(1);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(3, 0.3, 1); // BOSS血条更大
    sprite.position.y = 2.5; // 更高位置
    
    return { sprite, canvas, ctx, draw };
}

// 显示BOSS警告
function showBossWarning() {
    const warning = document.createElement('div');
    warning.style.cssText = `
        position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
        color: #ff0044; font-size: 48px; font-weight: bold;
        text-shadow: 0 0 20px #ff0044, 0 0 40px #ff0000;
        animation: blink 0.5s infinite; pointer-events: none; z-index: 100;
    `;
    warning.textContent = '⚠️ WARNING: BOSS APPROACHING ⚠️';
    document.body.appendChild(warning);
    
    setTimeout(() => {
        warning.remove();
    }, 3000);
}

// 创建爆炸
function createExplosion(position, color) {
    for (let i = 0; i < 8; i++) {
        const geo = new THREE.SphereGeometry(0.15, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(position);
        p.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.4
        );
        scene.add(p);
        particles.push(p);
    }
}

// 受伤
function takeDamage(amount) {
    health -= amount;
    if (health < 0) health = 0;
    document.getElementById('health-fill').style.width = health + '%';
    playHitSound();
    document.body.style.boxShadow = 'inset 0 0 100px #f00';
    setTimeout(() => document.body.style.boxShadow = 'none', 200);
    if (health <= 0) gameOver();
}

// 游戏结束
function gameOver() {
    isPlaying = false;
    document.getElementById('menu').style.display = 'flex';
    document.querySelector('#menu h1').textContent = '任务失败';
    document.querySelector('#menu p').innerHTML = '最终得分: ' + score + '<br>波次: ' + wave;
    document.querySelector('#menu button').textContent = '重新开始';
}

// 游戏主循环 - 完全重写，更安全
function update() {
    if (!isPlaying) return;
    frameCount++;
    
    // 玩家移动
    if (keys['KeyW'] || keys['ArrowUp']) player.position.z -= 0.18;
    if (keys['KeyS'] || keys['ArrowDown']) player.position.z += 0.18;
    if (keys['KeyA'] || keys['ArrowLeft']) player.position.x -= 0.18;
    if (keys['KeyD'] || keys['ArrowRight']) player.position.x += 0.18;
    player.position.x = Math.max(-10, Math.min(10, player.position.x));
    player.position.z = Math.max(-25, Math.min(8, player.position.z));
    const targetRotZ = (keys['KeyA'] ? 0.4 : 0) + (keys['KeyD'] ? -0.4 : 0);
    player.rotation.z += (targetRotZ - player.rotation.z) * 0.1;
    player.rotation.y = -player.rotation.z * 0.5;
    if (keys['Space']) shoot();
    
    // 更新玩家子弹
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.z -= 0.9;
        if (bullets[i].position.z < -50) {
            scene.remove(bullets[i]);
            bullets.splice(i, 1);
        }
    }
    
    // 生成敌机
    enemySpawnTimer++;
    const spawnRate = Math.max(60, 150 - wave * 3);
    if (enemySpawnTimer > spawnRate) {
        spawnEnemy();
        enemySpawnTimer = 0;
    }
    
    // 获取玩家碰撞盒（只计算一次）
    const playerBox = new THREE.Box3().setFromObject(player);
    const now = Date.now();
    
    // 更新敌机 - 使用反向循环安全删除
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        
        // 安全检查
        if (!e || !e.mesh) {
            enemies.splice(i, 1);
            continue;
        }
        
        // BOSS特殊行为
        if (e.isBoss) {
            // BOSS左右移动
            e.mesh.position.x = Math.sin(now * 0.001) * 3;
            // BOSS缓慢旋转展示
            e.mesh.rotation.y = Math.PI + Math.sin(now * 0.0005) * 0.2;
            // BOSS发射弹幕
            if (now - e.lastShot > e.shootInterval) {
                bossShoot(e);
                e.lastShot = now;
            }
        } else {
            // 普通敌机行为
            e.mesh.position.z += e.speed;
            e.mesh.rotation.set(0, Math.PI, 0);
        }
        
        // 更新血条
        if (e.healthBar && e.healthBar.draw) {
            try {
                e.healthBar.draw(e.hp / e.maxHp);
                if (e.healthBar.sprite && e.healthBar.sprite.material) {
                    e.healthBar.sprite.material.map.needsUpdate = true;
                }
            } catch(err) { console.log('Health bar error:', err); }
        }
        
        const enemyBox = new THREE.Box3().setFromObject(e.mesh);
        
        // 撞击检测
        if (playerBox.intersectsBox(enemyBox)) {
            takeDamage(20);
            createExplosion(e.mesh.position, 0xff0000);
            scene.remove(e.mesh);
            enemies.splice(i, 1);
            continue;
        }
        
        // 飞出屏幕
        if (e.mesh.position.z > 10) {
            scene.remove(e.mesh);
            enemies.splice(i, 1);
            continue;
        }
        
        // 子弹击中检测 - 增加伤害（2点）
        let hit = false;
        for (let j = bullets.length - 1; j >= 0; j--) {
            const bulletBox = new THREE.Box3().setFromObject(bullets[j]);
            if (bulletBox.intersectsBox(enemyBox)) {
                e.hp -= 2; // 一发子弹造成2点伤害
                scene.remove(bullets[j]);
                bullets.splice(j, 1);
                hit = true;
                
                if (e.hp <= 0) {
                    const color = e.type === 'fast' ? 0xff6600 : e.type === 'heavy' ? 0xff00ff : 0xff0000;
                    createExplosion(e.mesh.position, color);
                    playExplosionSound();
                    scene.remove(e.mesh);
                    enemies.splice(i, 1);
                    
                    const points = e.type === 'fast' ? 120 : e.type === 'heavy' ? 350 : 220;
                    score += points;
                    document.getElementById('score').textContent = 'SCORE: ' + score;
                    
                    if (score > wave * 1000) {
                        wave++;
                        document.getElementById('wave').textContent = 'WAVE: ' + wave;
                    }
                }
                break;
            }
        }
        if (hit) continue;
    }
    
    // 更新敌机子弹（包括BOSS弹幕）
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        if (b.userData.velocity) {
            b.position.add(b.userData.velocity);
        } else {
            b.position.z += 0.5;
        }
        
        // 检测击中玩家（BOSS子弹伤害更高）
        const bulletBox = new THREE.Box3().setFromObject(b);
        if (bulletBox.intersectsBox(playerBox)) {
            // 根据子弹大小判断是否为BOSS子弹
            const isBossBullet = b.geometry.parameters.radius > 0.25;
            takeDamage(isBossBullet ? 20 : 15);
            scene.remove(b);
            enemyBullets.splice(i, 1);
            continue;
        }
        
        // 飞出屏幕
        if (b.position.z > 15) {
            scene.remove(b);
            enemyBullets.splice(i, 1);
        }
    }
    
    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (p.userData.velocity) {
            p.position.add(p.userData.velocity);
        }
        p.scale.multiplyScalar(0.96);
        if (p.scale.x < 0.01) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(update);
}

// 开始游戏
function startGame() {
    initAudio();
    document.getElementById('menu').style.display = 'none';
    
    // 重置所有状态
    score = 0;
    wave = 1;
    health = 100;
    frameCount = 0;
    enemySpawnTimer = 0;
    lastShot = 0;
    
    document.getElementById('score').textContent = 'SCORE: 0';
    document.getElementById('wave').textContent = 'WAVE: 1';
    document.getElementById('health-fill').style.width = '100%';
    
    // 清理所有对象
    enemies.forEach(e => { if (e.mesh) scene.remove(e.mesh); });
    enemies = [];
    bullets.forEach(b => scene.remove(b));
    bullets = [];
    enemyBullets.forEach(b => scene.remove(b));
    enemyBullets = [];
    particles.forEach(p => scene.remove(p));
    particles = [];
    
    player.position.set(0, 0, 5);
    player.rotation.set(0, 0, 0);
    
    isPlaying = true;
    update();
}

// 初始化
init();
renderer.render(scene, camera);
</script>
</body>
</html>