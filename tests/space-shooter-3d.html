<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D å¤ªç©ºå°„å‡» - å‡çº§ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        #game-container { width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; padding: 20px; color: #0ff; font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #0ff; }
        #score { top: 20px; left: 20px; }
        #health { top: 20px; right: 20px; }
        #wave { top: 60px; left: 20px; color: #ff0; }
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #menu h1 { color: #0ff; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 20px #0ff; }
        #menu p { color: #fff; margin-bottom: 30px; text-align: center; }
        #menu button { padding: 15px 40px; font-size: 24px; background: linear-gradient(45deg, #00aaff, #0066cc); color: white; border: none; border-radius: 30px; cursor: pointer; }
        #menu button:hover { transform: scale(1.1); }
        .health-bar { width: 200px; height: 20px; background: #333; border: 2px solid #0ff; border-radius: 10px; overflow: hidden; }
        .health-fill { height: 100%; background: linear-gradient(90deg, #f00, #0f0); width: 100%; transition: width 0.3s; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui">
        <div class="hud" id="score">åˆ†æ•°: 0</div>
        <div class="hud" id="wave">æ³¢æ¬¡: 1</div>
        <div class="hud" id="health">
            ç”Ÿå‘½å€¼
            <div class="health-bar">
                <div class="health-fill" id="health-fill"></div>
            </div>
        </div>
    </div>
    <div id="menu">
        <h1>ğŸš€ 3D å¤ªç©ºå°„å‡»</h1>
        <p>WASD ç§»åŠ¨ | ç©ºæ ¼ å°„å‡»<br>æ•Œæœºæ’å‡»ä½ ä¼šæ‰£è¡€ï¼å°å¿ƒèº²é¿ï¼</p>
        <button onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
    </div>

<script>
// æ¸¸æˆå…¨å±€å˜é‡
let scene, camera, renderer, player;
let bullets = [], enemies = [], particles = [];
let score = 0, wave = 1, health = 100;
let isPlaying = false;
let keys = {};
let lastShot = 0;
let enemySpawnTimer = 0;
let difficultyMultiplier = 1;

// Web Audio ä¸Šä¸‹æ–‡
let audioCtx;

// åˆå§‹åŒ–éŸ³æ•ˆ
function initAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

// æ’­æ”¾å°„å‡»éŸ³æ•ˆ
function playShootSound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}

// æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
function playExplosionSound() {
    if (!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.3;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1000;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    noise.start();
}

// æ’­æ”¾å—ä¼¤éŸ³æ•ˆ
function playHitSound() {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.3);
}

// åˆå§‹åŒ–åœºæ™¯
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, -5);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('game-container').appendChild(renderer.domElement);
    
    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    
    // æ˜Ÿç©ºèƒŒæ™¯
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1000;
    const positions = new Float32Array(starCount * 3);
    for(let i = 0; i < starCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1});
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);
    
    // ç©å®¶é£èˆ¹
    const geometry = new THREE.ConeGeometry(0.5, 1.5, 8);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshPhongMaterial({ 
        color: 0x00aaff, 
        emissive: 0x002244,
        shininess: 100 
    });
    player = new THREE.Mesh(geometry, material);
    player.position.set(0, 0, 5);
    scene.add(player);
    
    // äº‹ä»¶ç›‘å¬
    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);
    window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// åˆ›å»ºå­å¼¹
function shoot() {
    const now = Date.now();
    if (now - lastShot < 200) return;
    lastShot = now;
    
    playShootSound();
    
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    const bullet = new THREE.Mesh(geometry, material);
    bullet.position.copy(player.position);
    bullet.position.y = 0;
    scene.add(bullet);
    bullets.push(bullet);
}

// åˆ›å»ºæ•Œæœº
function spawnEnemy() {
    const types = ['normal', 'fast', 'heavy'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    let geometry, color, speed, hp;
    
    if (type === 'fast') {
        geometry = new THREE.TetrahedronGeometry(0.4);
        color = 0xffaa00;
        speed = 0.25 * difficultyMultiplier;
        hp = 1;
    } else if (type === 'heavy') {
        geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        color = 0xff00ff;
        speed = 0.1 * difficultyMultiplier;
        hp = 3;
    } else {
        geometry = new THREE.ConeGeometry(0.4, 0.8, 4);
        color = 0xff0000;
        speed = 0.15 * difficultyMultiplier;
        hp = 1;
    }
    
    const material = new THREE.MeshPhongMaterial({ color: color });
    const enemy = new THREE.Mesh(geometry, material);
    enemy.position.set(
        (Math.random() - 0.5) * 16,
        0,
        -40 - Math.random() * 10
    );
    enemy.rotation.x = Math.PI;
    scene.add(enemy);
    
    enemies.push({
        mesh: enemy,
        speed: speed,
        hp: hp,
        maxHp: hp,
        type: type
    });
}

// åˆ›å»ºçˆ†ç‚¸ç²’å­
function createExplosion(position, color) {
    for (let i = 0; i < 15; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 4, 4);
        const material = new THREE.MeshBasicMaterial({ color: color });
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);
        particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5
        );
        scene.add(particle);
        particles.push(particle);
    }
}

// ç©å®¶å—ä¼¤
function takeDamage(amount) {
    health -= amount;
    if (health < 0) health = 0;
    document.getElementById('health-fill').style.width = health + '%';
    playHitSound();
    
    // å±å¹•é—ªçº¢
    document.body.style.background = '#500';
    setTimeout(() => document.body.style.background = '#000', 100);
    
    if (health <= 0) {
        gameOver();
    }
}

// æ¸¸æˆç»“æŸ
function gameOver() {
    isPlaying = false;
    document.getElementById('menu').style.display = 'flex';
    document.querySelector('#menu h1').textContent = 'æ¸¸æˆç»“æŸ';
    document.querySelector('#menu p').innerHTML = `æœ€ç»ˆå¾—åˆ†: ${score}<br>æ³¢æ¬¡: ${wave}`;
    document.querySelector('#menu button').textContent = 'é‡æ–°å¼€å§‹';
}

// æ¸¸æˆä¸»å¾ªç¯
function update() {
    if (!isPlaying) return;
    
    // ç©å®¶ç§»åŠ¨
    if (keys['KeyW'] || keys['ArrowUp']) player.position.z -= 0.2;
    if (keys['KeyS'] || keys['ArrowDown']) player.position.z += 0.2;
    if (keys['KeyA'] || keys['ArrowLeft']) player.position.x -= 0.2;
    if (keys['KeyD'] || keys['ArrowRight']) player.position.x += 0.2;
    
    // é™åˆ¶ç©å®¶ç§»åŠ¨èŒƒå›´
    player.position.x = Math.max(-10, Math.min(10, player.position.x));
    player.position.z = Math.max(-30, Math.min(8, player.position.z));
    
    // å€¾æ–œæ•ˆæœ
    player.rotation.z = (keys['KeyA'] ? 0.3 : 0) + (keys['KeyD'] ? -0.3 : 0);
    
    // å°„å‡»
    if (keys['Space']) shoot();
    
    // æ›´æ–°å­å¼¹
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.z -= 0.8;
        if (bullets[i].position.z < -50) {
            scene.remove(bullets[i]);
            bullets.splice(i, 1);
        }
    }
    
    // ç”Ÿæˆæ•Œæœº
    enemySpawnTimer++;
    let spawnRate = Math.max(30, 120 - wave * 10);
    if (enemySpawnTimer > spawnRate) {
        spawnEnemy();
        enemySpawnTimer = 0;
    }
    
    // æ›´æ–°æ•Œæœº
    const playerBox = new THREE.Box3().setFromObject(player);
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        enemy.mesh.position.z += enemy.speed;
        enemy.mesh.rotation.y += 0.05;
        
        const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);
        
        // æ•Œæœºæ’å‡»ç©å®¶æ£€æµ‹ï¼
        if (playerBox.intersectsBox(enemyBox)) {
            takeDamage(20); // æ‰£20%è¡€
            createExplosion(enemy.mesh.position, 0xff0000);
            scene.remove(enemy.mesh);
            enemies.splice(i, 1);
            continue;
        }
        
        // å­å¼¹å‡»ä¸­æ•Œæœº
        for (let j = bullets.length - 1; j >= 0; j--) {
            const bulletBox = new THREE.Box3().setFromObject(bullets[j]);
            if (bulletBox.intersectsBox(enemyBox)) {
                enemy.hp--;
                scene.remove(bullets[j]);
                bullets.splice(j, 1);
                
                if (enemy.hp <= 0) {
                    createExplosion(enemy.mesh.position, enemy.mesh.material.color);
                    playExplosionSound();
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    // è®¡åˆ†
                    let points = enemy.type === 'fast' ? 200 : enemy.type === 'heavy' ? 300 : 100;
                    score += points;
                    document.getElementById('score').textContent = 'åˆ†æ•°: ' + score;
                    
                    // æ¯500åˆ†å‡çº§æ³¢æ¬¡
                    if (score > wave * 500) {
                        wave++;
                        difficultyMultiplier += 0.2;
                        document.getElementById('wave').textContent = 'æ³¢æ¬¡: ' + wave;
                    }
                }
                break;
            }
        }
        
        // æ•Œæœºé£å‡ºå±å¹•
        if (enemy.mesh.position.z > 10) {
            scene.remove(enemy.mesh);
            enemies.splice(i, 1);
        }
    }
    
    // æ›´æ–°ç²’å­
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].position.add(particles[i].velocity);
        particles[i].scale.multiplyScalar(0.95);
        if (particles[i].scale.x < 0.01) {
            scene.remove(particles[i]);
            particles.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(update);
}

// å¼€å§‹æ¸¸æˆ
function startGame() {
    initAudio();
    document.getElementById('menu').style.display = 'none';
    
    // é‡ç½®æ¸¸æˆçŠ¶æ€
    score = 0;
    wave = 1;
    health = 100;
    difficultyMultiplier = 1;
    document.getElementById('score').textContent = 'åˆ†æ•°: 0';
    document.getElementById('wave').textContent = 'æ³¢æ¬¡: 1';
    document.getElementById('health-fill').style.width = '100%';
    
    // æ¸…é™¤æ—§æ•Œæœº
    enemies.forEach(e => scene.remove(e.mesh));
    enemies = [];
    bullets.forEach(b => scene.remove(b));
    bullets = [];
    particles.forEach(p => scene.remove(p));
    particles = [];
    
    // é‡ç½®ç©å®¶ä½ç½®
    player.position.set(0, 0, 5);
    
    isPlaying = true;
    update();
}

// åˆå§‹åŒ–
init();
renderer.render(scene, camera);
</script>
</body>
</html>
