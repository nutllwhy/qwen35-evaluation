<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense - å¡”é˜²æ¸¸æˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }
        h1 { margin-bottom: 10px; color: #0ff; text-shadow: 0 0 10px #0ff; }
        
        #gameContainer {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        canvas {
            border: 3px solid #444;
            border-radius: 8px;
            cursor: crosshair;
        }
        
        #sidebar {
            width: 200px;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        
        .stat {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            font-size: 14px;
        }
        .stat span { color: #0f0; font-weight: bold; }
        
        #towerSelect {
            margin-top: 20px;
        }
        
        #towerSelect h3 {
            margin-bottom: 15px;
            color: #ff0;
            text-align: center;
            font-size: 16px;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }
        
        .tower-btn {
            width: 100%;
            padding: 15px 10px;
            margin: 10px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            text-align: center;
        }
        .tower-btn:hover { transform: scale(1.05); }
        .tower-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .arrow-tower { 
            background: linear-gradient(135deg, #2d5a2d, #4a8);
            color: #fff;
            border-left: 4px solid #0f0;
        }
        .cannon-tower { 
            background: linear-gradient(135deg, #5a2d2d, #a44);
            color: #fff;
            border-left: 4px solid #f00;
        }
        .ice-tower { 
            background: linear-gradient(135deg, #2d2d5a, #44a);
            color: #fff;
            border-left: 4px solid #0af;
        }
        .tower-btn.selected {
            box-shadow: 0 0 20px currentColor;
            transform: scale(1.05);
        }
        
        #waveBtn {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            background: linear-gradient(135deg, #f50, #f80);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
        #waveBtn:disabled { background: #444; }
        
        #instructions {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,255,255,0.05);
            border: 1px solid #0ff;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.8;
            color: #aff;
        }
        #instructions strong {
            color: #fff;
        }
        
        #gameOver {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }
        #gameOver h2 { font-size: 48px; color: #f55; margin-bottom: 20px; }
        #gameOver button {
            padding: 15px 40px;
            font-size: 20px;
            background: #0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>ğŸ° TOWER DEFENSE ğŸ°</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="sidebar">
            <div class="stat">â¤ï¸ ç”Ÿå‘½å€¼: <span id="lives">20</span></div>
            <div class="stat">ğŸ’° é‡‘å¸: <span id="gold">100</span></div>
            <div class="stat">ğŸŒŠ æ³¢æ¬¡: <span id="wave">1</span>/10</div>
            <div class="stat">ğŸ‘¹ æ•Œäºº: <span id="enemies">0</span></div>
            
            <div id="towerSelect">
                <h3>ğŸ›¡ï¸ é€‰æ‹©é˜²å¾¡å¡”</h3>
                <button class="tower-btn arrow-tower" onclick="selectTower('arrow')">
                    <div style="font-size: 20px; margin-bottom: 4px;">ğŸ”º</div>
                    <div style="font-weight: bold;">ç®­å¡”</div>
                    <div style="font-size: 11px; opacity: 0.9;">æ”»é€Ÿå¿« | ä¼¤å®³15 | $50</div>
                </button>
                <button class="tower-btn cannon-tower" onclick="selectTower('cannon')">
                    <div style="font-size: 20px; margin-bottom: 4px;">ğŸ’¥</div>
                    <div style="font-weight: bold;">ç‚®å¡”</div>
                    <div style="font-size: 11px; opacity: 0.9;">æº…å°„ä¼¤å®³ | ä¼¤å®³40 | $100</div>
                </button>
                <button class="tower-btn ice-tower" onclick="selectTower('ice')">
                    <div style="font-size: 20px; margin-bottom: 4px;">â„ï¸</div>
                    <div style="font-weight: bold;">å†°å¡”</div>
                    <div style="font-size: 11px; opacity: 0.9;">å‡é€Ÿ50% | ä¼¤å®³8 | $80</div>
                </button>
            </div>
            
            <button id="waveBtn" onclick="startWave()">âš”ï¸ å¼€å§‹ä¸‹ä¸€æ³¢</button>
            
            <div id="instructions">
                <strong>ğŸ® æ¸¸æˆè¯´æ˜:</strong><br>
                1ï¸âƒ£ ç‚¹å‡»ä¸‹æ–¹é€‰æ‹©é˜²å¾¡å¡”ç±»å‹<br>
                2ï¸âƒ£ åœ¨åœ°å›¾ç»¿è‰²åŒºåŸŸç‚¹å‡»å»ºé€ <br>
                3ï¸âƒ£ ç‚¹å‡»å·²å»ºå¡”å¯å‡çº§/å‡ºå”®<br>
                4ï¸âƒ£ ç‚¹å‡»ã€Œå¼€å§‹ä¸‹ä¸€æ³¢ã€å‡ºå…µ<br><br>
                <strong>ğŸ”º ç®­å¡”:</strong> æ”»é€Ÿå¿«ï¼Œå•ä½“ä¼¤å®³<br>
                <strong>ğŸ’¥ ç‚®å¡”:</strong> èŒƒå›´æº…å°„ä¼¤å®³<br>
                <strong>â„ï¸ å†°å¡”:</strong> å‡é€Ÿæ•Œäºº
            </div>
        </div>
    </div>
    
    <div id="gameOver">
        <h2>GAME OVER</h2>
        <p style="font-size: 24px; margin-bottom: 20px;">æœ€ç»ˆæ³¢æ¬¡: <span id="finalWave"></span></p>
        <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// æ¸¸æˆçŠ¶æ€
let gameState = 'playing'; // playing, gameover
let lives = 20;
let gold = 100;
let wave = 1;
let selectedTower = null;
let waveActive = false;

// è·¯å¾„ç‚¹
const path = [
    {x: 0, y: 100}, {x: 150, y: 100}, {x: 200, y: 150},
    {x: 200, y: 300}, {x: 300, y: 400}, {x: 450, y: 400},
    {x: 500, y: 350}, {x: 500, y: 200}, {x: 600, y: 150},
    {x: 750, y: 150}, {x: 800, y: 200}
];

// å®ä½“
let towers = [];
let enemies = [];
let projectiles = [];
let particles = [];

// é˜²å¾¡å¡”ç±»å‹
const TOWER_TYPES = {
    arrow: {
        name: 'ç®­å¡”',
        cost: 50,
        damage: 15,
        range: 120,
        fireRate: 30,
        color: '#4a4',
        projectileSpeed: 8
    },
    cannon: {
        name: 'ç‚®å¡”',
        cost: 100,
        damage: 40,
        range: 150,
        fireRate: 60,
        color: '#a44',
        splash: 50,
        projectileSpeed: 6
    },
    ice: {
        name: 'å†°å¡”',
        cost: 80,
        damage: 8,
        range: 100,
        fireRate: 40,
        color: '#44a',
        slow: 0.5,
        slowDuration: 120,
        projectileSpeed: 10
    }
};

// æ•Œäººç±»å‹
const ENEMY_TYPES = {
    basic: { hp: 30, speed: 1.5, reward: 10, color: '#f55', radius: 12 },
    fast: { hp: 20, speed: 2.5, reward: 15, color: '#fa5', radius: 10 },
    tank: { hp: 80, speed: 0.8, reward: 30, color: '#888', radius: 15 },
    boss: { hp: 300, speed: 0.5, reward: 100, color: '#f0f', radius: 20 }
};

// ç»˜åˆ¶è·¯å¾„
function drawPath() {
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 40;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
    
    // è·¯å¾„è¾¹æ¡†
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 44;
    ctx.stroke();
    
    // èµ·ç‚¹å’Œç»ˆç‚¹
    ctx.fillStyle = '#0f0';
    ctx.fillRect(path[0].x - 10, path[0].y - 10, 20, 20);
    ctx.fillStyle = '#f00';
    ctx.fillRect(path[path.length-1].x - 15, path[path.length-1].y - 15, 30, 30);
}

// æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨è·¯å¾„ä¸Šï¼ˆç”¨äºå»ºé€ æ£€æµ‹ï¼‰
function isOnPath(x, y) {
    for (let i = 0; i < path.length - 1; i++) {
        const p1 = path[i], p2 = path[i+1];
        const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
        if (dist < 35) return true;
    }
    return false;
}

function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = dot / lenSq;
    param = Math.max(0, Math.min(1, param));
    const xx = x1 + param * C, yy = y1 + param * D;
    return Math.hypot(px - xx, py - yy);
}

// é˜²å¾¡å¡”ç±»
class Tower {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.level = 1;
        this.cooldown = 0;
        const stats = TOWER_TYPES[type];
        this.damage = stats.damage;
        this.range = stats.range;
        this.fireRate = stats.fireRate;
        this.color = stats.color;
    }
    
    update() {
        if (this.cooldown > 0) this.cooldown--;
        
        // å¯»æ‰¾ç›®æ ‡
        let target = null;
        let minDist = Infinity;
        
        for (let enemy of enemies) {
            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
            if (dist <= this.range && dist < minDist) {
                minDist = dist;
                target = enemy;
            }
        }
        
        if (target && this.cooldown <= 0) {
            this.shoot(target);
            this.cooldown = this.fireRate;
        }
    }
    
    shoot(target) {
        const stats = TOWER_TYPES[this.type];
        projectiles.push({
            x: this.x, y: this.y,
            target: target,
            damage: this.damage,
            speed: stats.projectileSpeed,
            color: this.color,
            type: this.type,
            splash: stats.splash,
            slow: stats.slow,
            slowDuration: stats.slowDuration
        });
    }
    
    draw() {
        // èŒƒå›´åœˆï¼ˆé€‰ä¸­æ—¶ï¼‰
        if (selectedTower === this) {
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // å¡”åŸºåº§ - æ‰€æœ‰å¡”å…±ç”¨
        ctx.fillStyle = '#2a2a3a';
        ctx.fillRect(this.x - 22, this.y - 22, 44, 44);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 22, this.y - 22, 44, 44);
        
        // æ ¹æ®å¡”ç±»å‹ç»˜åˆ¶ä¸åŒå½¢çŠ¶
        switch(this.type) {
            case 'arrow':
                this.drawArrowTower();
                break;
            case 'cannon':
                this.drawCannonTower();
                break;
            case 'ice':
                this.drawIceTower();
                break;
        }
        
        // ç­‰çº§æ ‡è®° - åœ¨å³ä¸Šè§’
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Lv' + this.level, this.x + 14, this.y - 12);
    }
    
    drawArrowTower() {
        // ç®­å¡” - ä¸‰è§’å½¢ç®­å¤´å½¢çŠ¶
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0f0';
        
        // ä¸»ä½“ - ç»¿è‰²ä¸‰è§’å½¢
        ctx.fillStyle = '#4a4';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 18);
        ctx.lineTo(this.x + 15, this.y + 12);
        ctx.lineTo(this.x - 15, this.y + 12);
        ctx.closePath();
        ctx.fill();
        
        // å†…éƒ¨è£…é¥° - å°ä¸‰è§’å½¢
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 8);
        ctx.lineTo(this.x + 6, this.y + 6);
        ctx.lineTo(this.x - 6, this.y + 6);
        ctx.closePath();
        ctx.fill();
        
        // å‘å°„å£
        ctx.fillStyle = '#2f2';
        ctx.beginPath();
        ctx.arc(this.x, this.y - 5, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    drawCannonTower() {
        // ç‚®å¡” - åœ†å½¢ç‚®å°å½¢çŠ¶
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#f00';
        
        // ä¸»ä½“ - çº¢è‰²åœ†å½¢
        ctx.fillStyle = '#a44';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
        ctx.fill();
        
        // å¤–åœˆ
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
        ctx.stroke();
        
        // å†…éƒ¨åå­—
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(this.x - 8, this.y);
        ctx.lineTo(this.x + 8, this.y);
        ctx.moveTo(this.x, this.y - 8);
        ctx.lineTo(this.x, this.y + 8);
        ctx.stroke();
        
        // ä¸­å¿ƒç‚¹
        ctx.fillStyle = '#f88';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    drawIceTower() {
        // å†°å¡” - è±å½¢æ°´æ™¶å½¢çŠ¶
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0af';
        
        // ä¸»ä½“ - è“è‰²è±å½¢
        ctx.fillStyle = '#44a';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 18);
        ctx.lineTo(this.x + 12, this.y);
        ctx.lineTo(this.x, this.y + 18);
        ctx.lineTo(this.x - 12, this.y);
        ctx.closePath();
        ctx.fill();
        
        // å†…éƒ¨è±å½¢
        ctx.fillStyle = '#66c';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 10);
        ctx.lineTo(this.x + 7, this.y);
        ctx.lineTo(this.x, this.y + 10);
        ctx.lineTo(this.x - 7, this.y);
        ctx.closePath();
        ctx.fill();
        
        // ä¸­å¿ƒæ ¸å¿ƒ
        ctx.fillStyle = '#0af';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // å†°æ™¶è£…é¥°
        ctx.strokeStyle = '#8af';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const angle = (i * Math.PI / 2) + Math.PI / 4;
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(angle) * 10, this.y + Math.sin(angle) * 10);
            ctx.lineTo(this.x + Math.cos(angle) * 16, this.y + Math.sin(angle) * 16);
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    upgrade() {
        const cost = Math.floor(TOWER_TYPES[this.type].cost * 0.7 * this.level);
        if (gold >= cost) {
            gold -= cost;
            this.level++;
            this.damage = Math.floor(this.damage * 1.3);
            this.range = Math.floor(this.range * 1.1);
            updateUI();
            return true;
        }
        return false;
    }
}

// æ•Œäººç±»
class Enemy {
    constructor(type) {
        this.pathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.type = type;
        const stats = ENEMY_TYPES[type];
        this.maxHp = stats.hp * (1 + wave * 0.2);
        this.hp = this.maxHp;
        this.baseSpeed = stats.speed;
        this.speed = this.baseSpeed;
        this.reward = stats.reward;
        this.color = stats.color;
        this.radius = stats.radius;
        this.slowTimer = 0;
    }
    
    update() {
        // å‡é€Ÿæ•ˆæœ
        if (this.slowTimer > 0) {
            this.slowTimer--;
            if (this.slowTimer <= 0) this.speed = this.baseSpeed;
        }
        
        // æ²¿è·¯å¾„ç§»åŠ¨
        if (this.pathIndex < path.length - 1) {
            const target = path[this.pathIndex + 1];
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < this.speed) {
                this.pathIndex++;
                if (this.pathIndex >= path.length - 1) {
                    return true; // åˆ°è¾¾ç»ˆç‚¹
                }
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }
        return false;
    }
    
    takeDamage(dmg, slow, slowDuration) {
        this.hp -= dmg;
        if (slow) {
            this.speed = this.baseSpeed * slow;
            this.slowTimer = slowDuration;
        }
        return this.hp <= 0;
    }
    
    draw() {
        // è¡€æ¡
        const hpPercent = this.hp / this.maxHp;
        ctx.fillStyle = '#300';
        ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30, 5);
        ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : '#f00';
        ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30 * hpPercent, 5);
        
        // æ•Œäººæœ¬ä½“
        ctx.fillStyle = this.slowTimer > 0 ? '#88f' : this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // å‡é€Ÿæ•ˆæœåœˆ
        if (this.slowTimer > 0) {
            ctx.strokeStyle = '#88f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ç”Ÿæˆç²’å­
function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 1.0,
            color: color
        });
    }
}

// æ³¢æ¬¡é…ç½®
const WAVES = [
    { count: 5, types: ['basic'], interval: 60 },
    { count: 8, types: ['basic', 'fast'], interval: 50 },
    { count: 10, types: ['basic', 'fast', 'tank'], interval: 45 },
    { count: 12, types: ['fast', 'tank'], interval: 40 },
    { count: 1, types: ['boss'], interval: 100 },
    { count: 15, types: ['basic', 'fast', 'tank'], interval: 35 },
    { count: 8, types: ['tank'], interval: 80 },
    { count: 20, types: ['basic', 'fast'], interval: 25 },
    { count: 12, types: ['fast', 'tank'], interval: 30 },
    { count: 3, types: ['boss'], interval: 150 }
];

let waveEnemyCount = 0;
let waveSpawnTimer = 0;
let currentWaveConfig = null;

function startWave() {
    if (wave > WAVES.length || waveActive) return;
    
    waveActive = true;
    currentWaveConfig = WAVES[wave - 1];
    waveEnemyCount = 0;
    waveSpawnTimer = 0;
    document.getElementById('waveBtn').disabled = true;
    document.getElementById('waveBtn').textContent = 'ğŸŒŠ æ³¢æ¬¡è¿›è¡Œä¸­...';
}

function spawnEnemy() {
    if (!waveActive || !currentWaveConfig) return;
    
    waveSpawnTimer++;
    if (waveSpawnTimer >= currentWaveConfig.interval && waveEnemyCount < currentWaveConfig.count) {
        const types = currentWaveConfig.types;
        const type = types[Math.floor(Math.random() * types.length)];
        enemies.push(new Enemy(type));
        waveEnemyCount++;
        waveSpawnTimer = 0;
    }
    
    if (waveEnemyCount >= currentWaveConfig.count && enemies.length === 0) {
        waveActive = false;
        wave++;
        gold += 50; // æ³¢æ¬¡å¥–åŠ±
        document.getElementById('waveBtn').disabled = false;
        document.getElementById('waveBtn').textContent = 'âš”ï¸ å¼€å§‹ä¸‹ä¸€æ³¢';
        updateUI();
    }
}

// æ¸¸æˆæ›´æ–°
function update() {
    if (gameState !== 'playing') return;
    
    // æ›´æ–°é˜²å¾¡å¡”
    towers.forEach(t => t.update());
    
    // ç”Ÿæˆæ•Œäºº
    spawnEnemy();
    
    // æ›´æ–°æ•Œäºº
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.update()) {
            // åˆ°è¾¾ç»ˆç‚¹
            lives--;
            enemies.splice(i, 1);
            updateUI();
            if (lives <= 0) gameOver();
        } else if (enemy.hp <= 0) {
            // æ­»äº¡
            gold += enemy.reward;
            createParticles(enemy.x, enemy.y, enemy.color, 8);
            enemies.splice(i, 1);
            updateUI();
        }
    }
    
    // æ›´æ–°å­å¼¹
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        
        // è¿½è¸ªç›®æ ‡
        if (p.target && enemies.includes(p.target)) {
            const dx = p.target.x - p.x;
            const dy = p.target.y - p.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            }
            
            // ç¢°æ’æ£€æµ‹
            if (dist < p.target.radius + 8) {
                // å‘½ä¸­
                if (p.splash) {
                    // æº…å°„ä¼¤å®³
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - p.x, e.y - p.y);
                        if (d <= p.splash) {
                            if (e.takeDamage(p.damage * (1 - d/p.splash), p.slow, p.slowDuration)) {
                                gold += e.reward;
                                createParticles(e.x, e.y, e.color, 5);
                            }
                        }
                    });
                } else {
                    if (p.target.takeDamage(p.damage, p.slow, p.slowDuration)) {
                        gold += p.target.reward;
                    }
                }
                createParticles(p.x, p.y, p.color, 5);
                projectiles.splice(i, 1);
            }
        } else {
            // ç›®æ ‡å·²æ­»ï¼Œå­å¼¹ç»§ç»­é£
            p.x += p.vx || 0;
            p.y += p.vy || 0;
            if (p.x < 0 || p.x > 800 || p.y < 0 || p.y > 600) {
                projectiles.splice(i, 1);
            }
        }
    }
    
    // æ›´æ–°ç²’å­
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

// ç»˜åˆ¶
function draw() {
    // æ¸…ç©ºç”»å¸ƒ
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, 800, 600);
    
    // ç»˜åˆ¶ç½‘æ ¼
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= 800; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 600);
        ctx.stroke();
    }
    for (let y = 0; y <= 600; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(800, y);
        ctx.stroke();
    }
    
    // ç»˜åˆ¶è·¯å¾„
    drawPath();
    
    // ç»˜åˆ¶é˜²å¾¡å¡”
    towers.forEach(t => t.draw());
    
    // ç»˜åˆ¶æ•Œäºº
    enemies.forEach(e => e.draw());
    
    // ç»˜åˆ¶å­å¼¹
    projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // ç»˜åˆ¶ç²’å­
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // ç»˜åˆ¶å»ºé€ é¢„è§ˆ
    if (selectedTower && typeof selectedTower === 'string' && mousePos) {
        const type = TOWER_TYPES[selectedTower];
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(mousePos.x, mousePos.y, type.range, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = canBuild(mousePos.x, mousePos.y) ? '#0f0' : '#f00';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

let mousePos = null;

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mousePos = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
});

canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¡”
    for (let tower of towers) {
        if (Math.hypot(tower.x - x, tower.y - y) < 20) {
            selectedTower = tower;
            updateUI();
            return;
        }
    }
    
    // å»ºé€ å¡”
    if (typeof selectedTower === 'string') {
        if (canBuild(x, y)) {
            buildTower(x, y, selectedTower);
        }
    } else {
        selectedTower = null;
    }
    updateUI();
});

function canBuild(x, y) {
    if (x < 20 || x > 780 || y < 20 || y > 580) return false;
    if (isOnPath(x, y)) return false;
    for (let t of towers) {
        if (Math.hypot(t.x - x, t.y - y) < 40) return false;
    }
    return true;
}

function buildTower(x, y, type) {
    const cost = TOWER_TYPES[type].cost;
    if (gold >= cost) {
        gold -= cost;
        towers.push(new Tower(x, y, type));
        selectedTower = null;
        updateUI();
    }
}

function selectTower(type) {
    selectedTower = type;
    updateUI();
}

function updateUI() {
    document.getElementById('lives').textContent = lives;
    document.getElementById('gold').textContent = gold;
    document.getElementById('wave').textContent = wave;
    document.getElementById('enemies').textContent = enemies.length;
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.tower-btn').forEach(btn => {
        const type = btn.onclick.toString().match(/'(\w+)'/)[1];
        btn.disabled = gold < TOWER_TYPES[type].cost;
        // æ·»åŠ é€‰ä¸­çŠ¶æ€
        if (selectedTower === type) {
            btn.classList.add('selected');
        } else {
            btn.classList.remove('selected');
        }
    });
    
    // å‡çº§/å‡ºå”®èœå•
    const sidebar = document.getElementById('towerSelect');
    const existingMenu = document.getElementById('upgradeMenu');
    if (existingMenu) existingMenu.remove();
    
    if (selectedTower instanceof Tower) {
        const upgradeCost = Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.7 * selectedTower.level);
        const sellCost = Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.5 * selectedTower.level);
        
        const menu = document.createElement('div');
        menu.id = 'upgradeMenu';
        menu.innerHTML = `
            <hr style="margin: 15px 0; border-color: #444;">
            <h4>${TOWER_TYPES[selectedTower.type].name} (Lv.${selectedTower.level})</h4>
            <button class="tower-btn" style="background: #0a0; margin: 5px 0;" 
                onclick="upgradeSelected()" ${gold < upgradeCost ? 'disabled' : ''}>
                â¬†ï¸ å‡çº§ ($${upgradeCost})
            </button>
            <button class="tower-btn" style="background: #a00; margin: 5px 0;" onclick="sellSelected()">
                ğŸ’° å‡ºå”® ($${sellCost})
            </button>
        `;
        sidebar.appendChild(menu);
    }
}

function upgradeSelected() {
    if (selectedTower instanceof Tower) {
        selectedTower.upgrade();
        selectedTower = null;
        updateUI();
    }
}

function sellSelected() {
    if (selectedTower instanceof Tower) {
        const cost = Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.5 * selectedTower.level);
        gold += cost;
        towers = towers.filter(t => t !== selectedTower);
        selectedTower = null;
        updateUI();
    }
}

function gameOver() {
    gameState = 'gameover';
    document.getElementById('finalWave').textContent = wave;
    document.getElementById('gameOver').style.display = 'flex';
}

function restartGame() {
    gameState = 'playing';
    lives = 20;
    gold = 100;
    wave = 1;
    towers = [];
    enemies = [];
    projectiles = [];
    particles = [];
    waveActive = false;
    selectedTower = null;
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('waveBtn').disabled = false;
    document.getElementById('waveBtn').textContent = 'âš”ï¸ å¼€å§‹ä¸‹ä¸€æ³¢';
    updateUI();
}

// æ¸¸æˆå¾ªç¯
function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// å¯åŠ¨
gameLoop();
updateUI();
</script>
</body>
</html>