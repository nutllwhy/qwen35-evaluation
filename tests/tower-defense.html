<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§§ æ–°æ˜¥å¡”é˜²å¤§ä½œæˆ˜ ğŸ§§</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #1a0a0a 0%, #2d1810 50%, #1a0a0a 100%);
            color: #fff;
            font-family: 'Noto Serif SC', 'Microsoft YaHei', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        /* èƒŒæ™¯è£…é¥° */
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 0, 0.1) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }
        
        /* æ ‡é¢˜ */
        .header {
            text-align: center;
            margin-bottom: 15px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #c41e3a 0%, #8b1a1a 50%, #dc143c 100%);
            border-radius: 16px;
            border: 3px solid #ffd700;
            box-shadow: 0 8px 32px rgba(196, 30, 58, 0.4);
            position: relative;
            z-index: 2;
        }
        
        .header h1 {
            font-size: 32px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            letter-spacing: 8px;
        }
        
        .header .subtitle {
            font-size: 14px;
            color: #fff;
            margin-top: 5px;
            letter-spacing: 4px;
        }
        
        /* éŸ³é¢‘æŒ‰é’® */
        #audio-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #ffd700;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            z-index: 100;
        }
        
        /* ä¸»å®¹å™¨ */
        #gameContainer {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            position: relative;
            z-index: 2;
        }
        
        /* æ¸¸æˆåŒºåŸŸ */
        .game-section {
            background: linear-gradient(145deg, #dc143c 0%, #8b1a1a 50%, #8b0000 100%);
            padding: 15px;
            border-radius: 12px;
            border: 3px solid #ffd700;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        
        canvas {
            display: block;
            border-radius: 8px;
            cursor: crosshair;
            background: #2d5a3d; /* è‰åœ°ç»¿è‰² */
        }
        
        /* ä¾§è¾¹æ  */
        #sidebar {
            width: 220px;
            background: linear-gradient(145deg, #fff5e6 0%, #ffe4cc 100%);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #ffd700;
            box-shadow: 0 4px 16px rgba(139, 0, 0, 0.2);
        }
        
        /* çŠ¶æ€é¢æ¿ */
        .stat-panel {
            margin-bottom: 15px;
            padding: 12px;
            background: linear-gradient(135deg, #c41e3a, #8b1a1a);
            border-radius: 8px;
            border: 2px solid #ffd700;
            color: #fff;
        }
        
        .stat {
            margin: 8px 0;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-label { color: #ffd700; }
        .stat-value { color: #0f0; font-weight: bold; }
        
        /* éš¾åº¦é€‰æ‹© */
        .difficulty-section {
            margin-bottom: 15px;
        }
        
        .difficulty-section h3 {
            color: #8b4513;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .difficulty-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .diff-btn {
            padding: 8px;
            border: 2px solid #8b4513;
            background: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            color: #8b4513;
            transition: all 0.3s;
        }
        
        .diff-btn:hover, .diff-btn.active {
            background: #c41e3a;
            color: #fff;
            border-color: #c41e3a;
        }
        
        /* é˜²å¾¡å¡”é€‰æ‹© */
        #towerSelect h3 {
            color: #8b4513;
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 8px;
        }
        
        .tower-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #fff;
            font-weight: bold;
        }
        
        .tower-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tower-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: rgba(255,255,255,0.2);
        }
        
        .arrow-tower { 
            background: linear-gradient(135deg, #4a9, #2a7);
            border: 2px solid #0f0;
        }
        .cannon-tower { 
            background: linear-gradient(135deg, #a44, #722);
            border: 2px solid #f00;
        }
        .ice-tower { 
            background: linear-gradient(135deg, #49a, #247);
            border: 2px solid #0af;
        }
        
        /* æ³¢æ¬¡æŒ‰é’® */
        #waveBtn {
            width: 100%;
            padding: 15px;
            margin-top: 15px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: 3px solid #c41e3a;
            border-radius: 8px;
            color: #8b0000;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }
        
        #waveBtn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6);
        }
        
        #waveBtn:disabled {
            background: #666;
            border-color: #444;
            color: #999;
        }
        
        /* è§„åˆ™è¯´æ˜ */
        .rules-panel {
            margin-top: 15px;
            padding: 12px;
            background: rgba(139, 105, 20, 0.1);
            border-radius: 8px;
            border: 1px solid #ffd700;
        }
        
        .rules-panel h4 {
            color: #8b4513;
            font-size: 13px;
            margin-bottom: 8px;
        }
        
        .rules-content {
            font-size: 12px;
            line-height: 1.6;
            color: #8b4513;
        }
        
        .rules-content strong {
            color: #c41e3a;
        }
        
        /* æ¸¸æˆç»“æŸå¼¹çª— */
        #gameOver {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(139, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        #gameOver h2 {
            font-size: 56px;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            margin-bottom: 15px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #gameOver .final-score {
            font-size: 24px;
            color: #fff;
            margin-bottom: 15px;
        }
        
        #gameOver .blessing {
            font-size: 20px;
            color: #ffd700;
            margin-bottom: 30px;
            padding: 10px 25px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 25px;
            border: 2px solid #ffd700;
        }
        
        #gameOver button {
            padding: 18px 50px;
            font-size: 22px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: 3px solid #fff;
            border-radius: 30px;
            color: #8b0000;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            transition: all 0.3s;
        }
        
        #gameOver button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }
        
        /* é£˜è½è£…é¥° */
        .lantern {
            position: fixed;
            font-size: 28px;
            animation: float linear infinite;
            pointer-events: none;
            z-index: 1;
        }
        
        @keyframes float {
            to { transform: translateY(100vh) rotate(10deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® æ–°æ˜¥å¡”é˜² ğŸ®</h1>
        <div class="subtitle">å®ˆæŠ¤å®¶å›­ï¼Œå‡»é€€å¹´å…½</div>
        <button id="audio-toggle" onclick="toggleAudio()">ğŸ”Š</button>
    </div>
    
    <div id="gameContainer">
        <div class="game-section">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        
        <div id="sidebar">
            <div class="stat-panel">
                <div class="stat">
                    <span class="stat-label">â¤ï¸ ç”Ÿå‘½:</span>
                    <span class="stat-value" id="lives">20</span>
                </div>
                <div class="stat">
                    <span class="stat-label">ğŸ’° é‡‘å¸:</span>
                    <span class="stat-value" id="gold">100</span>
                </div>
                <div class="stat">
                    <span class="stat-label">ğŸŒŠ æ³¢æ¬¡:</span>
                    <span class="stat-value" id="wave">1</span>
                </div>
                <div class="stat">
                    <span class="stat-label">ğŸ‘¹ æ•Œäºº:</span>
                    <span class="stat-value" id="enemies">0</span>
                </div>
            </div>
            
            <div class="difficulty-section">
                <h3>ğŸ“œ éš¾åº¦é€‰æ‹©</h3>
                <div class="difficulty-buttons">
                    <button class="diff-btn" onclick="setDifficulty('easy')">å…¥é—¨</button>
                    <button class="diff-btn active" onclick="setDifficulty('medium')">æ™®é€š</button>
                    <button class="diff-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
                    <button class="diff-btn" onclick="setDifficulty('expert')">å¤§å¸ˆ</button>
                </div>
            </div>
            
            <div id="towerSelect">
                <h3>ğŸ›¡ï¸ é€‰æ‹©é˜²å¾¡å¡”</h3>
                
                <button class="tower-btn arrow-tower" onclick="selectTower('arrow')">
                    <div class="tower-icon">ğŸ¹</div>
                    <div>
                        <div>ç®­å¡” $50</div>
                        <small>æ”»é€Ÿå¿«ï¼Œå•ä½“ä¼¤å®³</small>
                    </div>
                </button>
                
                <button class="tower-btn cannon-tower" onclick="selectTower('cannon')">
                    <div class="tower-icon">ğŸ’£</div>
                    <div>
                        <div>ç‚®å¡” $100</div>
                        <small>æº…å°„ä¼¤å®³</small>
                    </div>
                </button>
                
                <button class="tower-btn ice-tower" onclick="selectTower('ice')">
                    <div class="tower-icon">â„ï¸</div>
                    <div>
                        <div>å†°å¡” $80</div>
                        <small>å‡é€Ÿæ•Œäºº</small>
                    </div>
                </button>
            </div>
            
            <button id="waveBtn" onclick="startWave()">âš”ï¸ å¼€å§‹ä¸‹ä¸€æ³¢</button>
            
            <div class="rules-panel">
                <h4>ğŸ“– æ¸¸æˆè§„åˆ™</h4>
                <div class="rules-content">
                    <strong>ğŸ¯ ç›®æ ‡:</strong> é˜»æ­¢å¹´å…½åˆ°è¾¾ç»ˆç‚¹<br>
                    <strong>ğŸ–±ï¸ æ“ä½œ:</strong> ç‚¹å‡»ç©ºåœ°å»ºå¡”<br>
                    <strong>â¬†ï¸ å‡çº§:</strong> ç‚¹å‡»å·²å»ºå¡”å‡çº§
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameOver">
        <h2>ğŸŠ æ¸¸æˆç»“æŸ ğŸŠ</h2>
        <div class="final-score">æœ€ç»ˆæ³¢æ¬¡: <span id="finalWave"></span></div>
        <div class="blessing" id="blessing">æ–°å¹´å¿«ä¹ï¼</div>
        <button onclick="restartGame()">ğŸ® å†æ¥ä¸€å±€</button>
    </div>

<script>
// ==================== éŸ³é¢‘ç³»ç»Ÿ ====================
let audioEnabled = true;
let audioContext = null;
let isBgmPlaying = false;
let bgmTimer = null;

// åˆå§‹åŒ–éŸ³é¢‘
async function initAudio() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    if (!isBgmPlaying && audioEnabled) {
        startBGM();
    }
}

async function toggleAudio() {
    audioEnabled = !audioEnabled;
    document.getElementById('audio-toggle').textContent = audioEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
    if (audioEnabled) {
        await initAudio();
    } else {
        stopBGM();
    }
}

// èƒŒæ™¯éŸ³ä¹ - å–œåº†å›½é£
const bgmNotes = [
    { n: 523.25, d: 0.25 }, { n: 587.33, d: 0.25 }, { n: 659.25, d: 0.25 }, { n: 783.99, d: 0.3 },
    { n: 659.25, d: 0.25 }, { n: 587.33, d: 0.25 }, { n: 523.25, d: 0.4 }, { n: 0, d: 0.1 },
    { n: 659.25, d: 0.25 }, { n: 698.46, d: 0.25 }, { n: 783.99, d: 0.25 }, { n: 880.00, d: 0.3 },
    { n: 783.99, d: 0.25 }, { n: 698.46, d: 0.25 }, { n: 659.25, d: 0.4 }
];

let bgmIndex = 0;
let nextNoteTime = 0;

function startBGM() {
    if (!audioEnabled || !audioContext || isBgmPlaying) return;
    isBgmPlaying = true;
    bgmIndex = 0;
    nextNoteTime = audioContext.currentTime;
    scheduleNotes();
}

function scheduleNotes() {
    if (!isBgmPlaying || !audioEnabled) return;
    
    const currentTime = audioContext.currentTime;
    
    while (nextNoteTime < currentTime + 0.5) {
        const note = bgmNotes[bgmIndex];
        if (note.n > 0) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            filter.type = 'lowpass';
            filter.frequency.value = 1200;
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = note.n;
            osc.type = 'triangle';
            gain.gain.setValueAtTime(0.06, nextNoteTime);
            gain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + note.d * 0.8);
            
            osc.start(nextNoteTime);
            osc.stop(nextNoteTime + note.d);
            
            // ä½éŸ³ä¼´å¥
            const bass = audioContext.createOscillator();
            const bassGain = audioContext.createGain();
            bass.frequency.value = note.n / 4;
            bassGain.gain.value = 0.03;
            bass.connect(bassGain);
            bassGain.connect(audioContext.destination);
            bass.start(nextNoteTime);
            bass.stop(nextNoteTime + note.d);
        }
        nextNoteTime += note.d;
        bgmIndex = (bgmIndex + 1) % bgmNotes.length;
    }
    bgmTimer = setTimeout(scheduleNotes, 100);
}

function stopBGM() {
    isBgmPlaying = false;
    if (bgmTimer) clearTimeout(bgmTimer);
}

// éŸ³æ•ˆ
function playShootSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.frequency.setValueAtTime(800, t);
    osc.frequency.exponentialRampToValueAtTime(400, t + 0.1);
    gain.gain.setValueAtTime(0.1, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
    osc.start(t);
    osc.stop(t + 0.1);
}

function playExplosionSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const bufferSize = audioContext.sampleRate * 0.15;
    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
    
    const noise = audioContext.createBufferSource();
    noise.buffer = buffer;
    const gain = audioContext.createGain();
    gain.gain.setValueAtTime(0.15, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
    noise.connect(gain);
    gain.connect(audioContext.destination);
    noise.start(t);
}

function playBuildSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.frequency.setValueAtTime(600, t);
    osc.frequency.linearRampToValueAtTime(900, t + 0.1);
    gain.gain.setValueAtTime(0.1, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    osc.start(t);
    osc.stop(t + 0.2);
}

function playLevelUpSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    [523.25, 659.25, 783.99].forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.frequency.value = freq;
        const start = t + i * 0.08;
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(0.15, start + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, start + 0.3);
        osc.start(start);
        osc.stop(start + 0.4);
    });
}

function playWinSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const notes = [523.25, 659.25, 783.99, 1046.50];
    notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.frequency.value = freq;
        const start = t + i * 0.1;
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(0.2, start + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.01, start + 0.5);
        osc.start(start);
        osc.stop(start + 0.6);
    });
}

// ==================== æ¸¸æˆä»£ç  ====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const blessings = [
    'æ–°å¹´å¿«ä¹ï¼Œä¸‡äº‹å¦‚æ„ï¼',
    'å¡”é˜²è¿æ˜¥ï¼Œæ­¥æ­¥é«˜å‡ï¼',
    'å®ˆå²æˆåŠŸï¼Œäº”ç¦ä¸´é—¨ï¼',
    'é¾™å¹´å¤§å‰ï¼Œæˆ˜æ— ä¸èƒœï¼',
    'çº¢çº¢ç«ç«ï¼Œå¥½è¿è¿è¿ï¼'
];

function createLanterns() {
    const decorations = ['ğŸ®', 'ğŸ§§', 'ğŸŠ', 'âœ¨'];
    for (let i = 0; i < 6; i++) {
        const lantern = document.createElement('div');
        lantern.className = 'lantern';
        lantern.textContent = decorations[Math.floor(Math.random() * decorations.length)];
        lantern.style.left = Math.random() * window.innerWidth + 'px';
        lantern.style.animationDuration = (Math.random() * 8 + 8) + 's';
        lantern.style.animationDelay = Math.random() * 5 + 's';
        document.body.appendChild(lantern);
        setTimeout(() => lantern.remove(), 16000);
    }
}

// è·¯å¾„ç‚¹
const path = [
    {x: 0, y: 100}, {x: 150, y: 100}, {x: 200, y: 150},
    {x: 200, y: 300}, {x: 300, y: 400}, {x: 450, y: 400},
    {x: 500, y: 350}, {x: 500, y: 200}, {x: 600, y: 150},
    {x: 750, y: 150}, {x: 800, y: 200}
];

// æ¸¸æˆçŠ¶æ€
let gameState = 'playing';
let lives = 20;
let gold = 100;
let wave = 1;
let selectedTower = null;
let waveActive = false;
let difficulty = 'medium';
let towers = [];
let enemies = [];
let projectiles = [];
let particles = [];

const TOWER_TYPES = {
    arrow: { name: 'ç®­å¡”', cost: 50, damage: 15, range: 120, fireRate: 30, color: '#4a4' },
    cannon: { name: 'ç‚®å¡”', cost: 100, damage: 40, range: 150, fireRate: 60, splash: 50, color: '#a44' },
    ice: { name: 'å†°å¡”', cost: 80, damage: 8, range: 100, fireRate: 40, slow: 0.5, slowDuration: 120, color: '#44a' }
};

const ENEMY_TYPES = {
    basic: { hp: 30, speed: 1.5, reward: 10, color: '#ff6b6b', radius: 12, name: 'å°å¹´å…½' },
    fast: { hp: 20, speed: 2.5, reward: 15, color: '#ffa502', radius: 10, name: 'å¿«å¹´å…½' },
    tank: { hp: 80, speed: 0.8, reward: 30, color: '#ff4757', radius: 15, name: 'å¤§å¹´å…½' },
    boss: { hp: 300, speed: 0.5, reward: 100, color: '#c41e3a', radius: 20, name: 'å¹´å…½ç‹' }
};

// ç»˜åˆ¶è·¯å¾„
function drawPath() {
    // è·¯å¾„ä¸»ä½“ - åœŸè·¯
    ctx.strokeStyle = '#8b7355';
    ctx.lineWidth = 40;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();
    
    // è·¯å¾„è¾¹æ¡†
    ctx.strokeStyle = '#6b5344';
    ctx.lineWidth = 44;
    ctx.stroke();
    
    // èµ·ç‚¹
    ctx.fillStyle = '#0f0';
    ctx.fillRect(path[0].x - 10, path[0].y - 10, 20, 20);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.fillText('èµ·', path[0].x - 6, path[0].y + 4);
    
    // ç»ˆç‚¹
    ctx.fillStyle = '#f00';
    ctx.fillRect(path[path.length-1].x - 15, path[path.length-1].y - 15, 30, 30);
    ctx.fillStyle = '#fff';
    ctx.fillText('ç»ˆ', path[path.length-1].x - 6, path[path.length-1].y + 4);
}

function isOnPath(x, y) {
    for (let i = 0; i < path.length - 1; i++) {
        const p1 = path[i], p2 = path[i+1];
        const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
        if (dist < 35) return true;
    }
    return false;
}

function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = dot / lenSq;
    param = Math.max(0, Math.min(1, param));
    const xx = x1 + param * C, yy = y1 + param * D;
    return Math.hypot(px - xx, py - yy);
}

class Tower {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; this.level = 1; this.cooldown = 0;
        const stats = TOWER_TYPES[type];
        this.damage = stats.damage;
        this.range = stats.range;
        this.fireRate = stats.fireRate;
        this.color = stats.color;
    }
    
    update() {
        if (this.cooldown > 0) this.cooldown--;
        let target = null, minDist = Infinity;
        for (let enemy of enemies) {
            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
            if (dist <= this.range && dist < minDist) {
                minDist = dist;
                target = enemy;
            }
        }
        if (target && this.cooldown <= 0) {
            this.shoot(target);
            this.cooldown = this.fireRate;
        }
    }
    
    shoot(target) {
        const stats = TOWER_TYPES[this.type];
        projectiles.push({
            x: this.x, y: this.y,
            target: target,
            damage: this.damage,
            speed: 8,
            color: this.color,
            type: this.type,
            splash: stats.splash,
            slow: stats.slow,
            slowDuration: stats.slowDuration
        });
        playShootSound();
    }
    
    draw() {
        if (selectedTower === this) {
            ctx.fillStyle = 'rgba(255,215,0,0.1)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,215,0,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // å¡”åŸºåº§
        ctx.fillStyle = '#5a4a3a';
        ctx.fillRect(this.x - 22, this.y - 22, 44, 44);
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 22, this.y - 22, 44, 44);
        
        // å¡”èº«ç»˜åˆ¶
        switch(this.type) {
            case 'arrow':
                this.drawArrowTower();
                break;
            case 'cannon':
                this.drawCannonTower();
                break;
            case 'ice':
                this.drawIceTower();
                break;
        }
        
        // ç­‰çº§æ ‡è®°
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Lv' + this.level, this.x + 14, this.y - 12);
    }
    
    drawArrowTower() {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0f0';
        ctx.fillStyle = '#4a4';
        ctx.fillRect(this.x - 8, this.y - 20, 16, 40);
        ctx.fillStyle = '#2f2';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 25);
        ctx.lineTo(this.x + 12, this.y + 5);
        ctx.lineTo(this.x - 12, this.y + 5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - 5, this.y + 10);
        ctx.lineTo(this.x + 5, this.y + 10);
        ctx.stroke();
        ctx.restore();
    }
    
    drawCannonTower() {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#f00';
        ctx.fillStyle = '#a44';
        ctx.beginPath();
        ctx.arc(this.x, this.y - 5, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(this.x - 8, this.y - 5);
        ctx.lineTo(this.x + 8, this.y - 5);
        ctx.moveTo(this.x, this.y - 13);
        ctx.lineTo(this.x, this.y + 3);
        ctx.stroke();
        ctx.restore();
    }
    
    drawIceTower() {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0af';
        ctx.fillStyle = '#44a';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 20);
        ctx.lineTo(this.x + 12, this.y);
        ctx.lineTo(this.x, this.y + 20);
        ctx.lineTo(this.x - 12, this.y);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#0af';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    upgrade() {
        const cost = Math.floor(TOWER_TYPES[this.type].cost * 0.7 * this.level);
        if (gold >= cost) {
            gold -= cost;
            this.level++;
            this.damage = Math.floor(this.damage * 1.3);
            this.range = Math.floor(this.range * 1.1);
            updateUI();
            playLevelUpSound();
            return true;
        }
        return false;
    }
}

class Enemy {
    constructor(type) {
        this.pathIndex = 0;
        this.x = path[0].x;
        this.y = path[0].y;
        this.type = type;
        const stats = ENEMY_TYPES[type];
        const hpMultiplier = type === 'boss' ? (1 + wave * 0.1) : (1 + wave * 0.15);
        this.maxHp = stats.hp * hpMultiplier;
        this.hp = this.maxHp;
        this.baseSpeed = stats.speed;
        this.speed = this.baseSpeed;
        this.reward = stats.reward;
        this.color = stats.color;
        this.radius = stats.radius;
        this.slowTimer = 0;
        this.active = true;
    }
    
    update() {
        if (this.slowTimer > 0) {
            this.slowTimer--;
            if (this.slowTimer <= 0) this.speed = this.baseSpeed;
        }
        
        if (this.pathIndex < path.length - 1) {
            const target = path[this.pathIndex + 1];
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < this.speed) {
                this.pathIndex++;
                if (this.pathIndex >= path.length - 1) return true;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }
        return false;
    }
    
    takeDamage(dmg, slow, slowDuration) {
        this.hp -= dmg;
        if (slow) {
            this.speed = this.baseSpeed * slow;
            this.slowTimer = slowDuration;
        }
        return this.hp <= 0;
    }
    
    draw() {
        const hpPercent = this.hp / this.maxHp;
        ctx.fillStyle = '#300';
        ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30, 5);
        ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : '#f00';
        ctx.fillRect(this.x - 15, this.y - this.radius - 10, 30 * hpPercent, 5);
        
        ctx.fillStyle = this.slowTimer > 0 ? '#88f' : this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // å¹´å…½è¡¨æƒ…
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 3, 3, 0, Math.PI * 2);
        ctx.arc(this.x + 5, this.y - 3, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y + 3, 6, 0, Math.PI);
        ctx.stroke();
        
        if (this.slowTimer > 0) {
            ctx.strokeStyle = '#88f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

const WAVES = [
    { count: 5, types: ['basic'], interval: 60 },
    { count: 8, types: ['basic', 'fast'], interval: 50 },
    { count: 10, types: ['basic', 'fast', 'tank'], interval: 45 },
    { count: 12, types: ['fast', 'tank'], interval: 40 },
    { count: 1, types: ['boss'], interval: 100 },
    { count: 15, types: ['basic', 'fast', 'tank'], interval: 35 },
    { count: 8, types: ['tank'], interval: 80 },
    { count: 20, types: ['basic', 'fast'], interval: 25 },
    { count: 12, types: ['fast', 'tank'], interval: 30 },
    { count: 3, types: ['boss'], interval: 150 }
];

let waveEnemyCount = 0;
let waveSpawnTimer = 0;
let currentWaveConfig = null;

function startWave() {
    if (wave > WAVES.length || waveActive) return;
    waveActive = true;
    currentWaveConfig = WAVES[wave - 1];
    waveEnemyCount = 0;
    waveSpawnTimer = 0;
    document.getElementById('waveBtn').disabled = true;
    document.getElementById('waveBtn').textContent = 'ğŸŒŠ å¹´å…½æ¥è¢­ä¸­...';
}

function createParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 1.0,
            color: color
        });
    }
}

function update() {
    if (gameState !== 'playing') return;
    
    towers.forEach(t => t.update());
    
    // ç”Ÿæˆæ•Œäºº
    if (waveActive && currentWaveConfig) {
        waveSpawnTimer++;
        if (waveSpawnTimer >= currentWaveConfig.interval && waveEnemyCount < currentWaveConfig.count) {
            const types = currentWaveConfig.types;
            const type = types[Math.floor(Math.random() * types.length)];
            enemies.push(new Enemy(type));
            waveEnemyCount++;
            waveSpawnTimer = 0;
        }
        
        if (waveEnemyCount >= currentWaveConfig.count && enemies.length === 0) {
            waveActive = false;
            wave++;
            gold += 50;
            document.getElementById('waveBtn').disabled = false;
            document.getElementById('waveBtn').textContent = 'âš”ï¸ å¼€å§‹ä¸‹ä¸€æ³¢';
            updateUI();
            playWinSound();
        }
    }
    
    // æ›´æ–°æ•Œäºº
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.update()) {
            lives--;
            enemies.splice(i, 1);
            updateUI();
            if (lives <= 0) {
                gameState = 'gameover';
                document.getElementById('blessing').textContent = blessings[Math.floor(Math.random() * blessings.length)];
                document.getElementById('finalWave').textContent = wave;
                document.getElementById('gameOver').style.display = 'flex';
                stopBGM();
            }
        } else if (enemy.hp <= 0) {
            gold += enemy.reward;
            createParticles(enemy.x, enemy.y, 10, enemy.color);
            enemies.splice(i, 1);
            updateUI();
            playExplosionSound();
        }
    }
    
    // æ›´æ–°å­å¼¹
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        if (p.target && enemies.includes(p.target)) {
            const dx = p.target.x - p.x;
            const dy = p.target.y - p.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            }
            
            if (dist < p.target.radius + 8) {
                if (p.splash) {
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - p.x, e.y - p.y);
                        if (d <= p.splash) {
                            if (e.takeDamage(p.damage * (1 - d/p.splash), p.slow, p.slowDuration)) {
                                gold += e.reward;
                                createParticles(e.x, e.y, 5, e.color);
                            }
                        }
                    });
                } else {
                    if (p.target.takeDamage(p.damage, p.slow, p.slowDuration)) {
                        gold += p.target.reward;
                    }
                }
                createParticles(p.x, p.y, 5, p.color);
                projectiles.splice(i, 1);
            }
        } else {
            projectiles.splice(i, 1);
        }
    }
    
    // æ›´æ–°ç²’å­
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    // è‰åœ°èƒŒæ™¯
    ctx.fillStyle = '#3d5c3d';
    ctx.fillRect(0, 0, 800, 600);
    
    // è‰åœ°çº¹ç†
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    for (let i = 0; i < 100; i++) {
        const x = (i * 37) % 800;
        const y = (i * 53) % 600;
        ctx.fillRect(x, y, 2, 2);
    }
    
    drawPath();
    towers.forEach(t => t.draw());
    enemies.forEach(e => e.draw());
    
    projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
    });
    
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
}

let mousePos = null;

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
});

canvas.addEventListener('click', async e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    initAudio();
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    
    for (let tower of towers) {
        if (Math.hypot(tower.x - x, tower.y - y) < 20) {
            selectedTower = tower;
            updateUI();
            return;
        }
    }
    
    if (typeof selectedTower === 'string') {
        if (canBuild(x, y)) {
            buildTower(x, y, selectedTower);
        }
    } else {
        selectedTower = null;
    }
    updateUI();
});

function canBuild(x, y) {
    if (x < 20 || x > 780 || y < 20 || y > 580) return false;
    if (isOnPath(x, y)) return false;
    for (let t of towers) {
        if (Math.hypot(t.x - x, t.y - y) < 40) return false;
    }
    return true;
}

function buildTower(x, y, type) {
    const cost = TOWER_TYPES[type].cost;
    if (gold >= cost) {
        gold -= cost;
        towers.push(new Tower(x, y, type));
        selectedTower = null;
        updateUI();
        playBuildSound();
    }
}

function selectTower(type) {
    selectedTower = type;
    updateUI();
}

function updateUI() {
    document.getElementById('lives').textContent = lives;
    document.getElementById('gold').textContent = gold;
    document.getElementById('wave').textContent = wave;
    document.getElementById('enemies').textContent = enemies.length;
    
    document.querySelectorAll('.tower-btn').forEach(btn => {
        const type = btn.onclick.toString().match(/'(\w+)'/)[1];
        btn.disabled = gold < TOWER_TYPES[type].cost;
        if (selectedTower === type) btn.classList.add('selected');
        else btn.classList.remove('selected');
    });
    
    const existingMenu = document.getElementById('upgradeMenu');
    if (existingMenu) existingMenu.remove();
    
    if (selectedTower instanceof Tower) {
        const sidebar = document.getElementById('towerSelect');
        const upgradeCost = Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.7 * selectedTower.level);
        const sellCost = Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.5 * selectedTower.level);
        
        const menu = document.createElement('div');
        menu.id = 'upgradeMenu';
        menu.innerHTML = `
            <hr style="margin: 15px 0; border-color: #ffd700;">
            <h4 style="color: #8b4513; text-align: center;">${TOWER_TYPES[selectedTower.type].name} (Lv.${selectedTower.level})</h4>
            <button class="tower-btn" style="background: linear-gradient(135deg, #4a9, #2a7); margin: 5px 0;" 
                onclick="upgradeSelected()" ${gold < upgradeCost ? 'disabled' : ''}>
                â¬†ï¸ å‡çº§ ($${upgradeCost})
            </button>
            <button class="tower-btn" style="background: linear-gradient(135deg, #a44, #722); margin: 5px 0;" onclick="sellSelected()">
                ğŸ’° å‡ºå”® ($${sellCost})
            </button>
        `;
        sidebar.appendChild(menu);
    }
}

function upgradeSelected() {
    if (selectedTower instanceof Tower) {
        selectedTower.upgrade();
        selectedTower = null;
        updateUI();
    }
}

function sellSelected() {
    if (selectedTower instanceof Tower) {
        const cost = Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.5 * selectedTower.level);
        gold += cost;
        towers = towers.filter(t => t !== selectedTower);
        selectedTower = null;
        updateUI();
    }
}

function setDifficulty(level) {
    difficulty = level;
    document.querySelectorAll('.diff-btn').forEach(btn => {
        btn.classList.toggle('active', 
            btn.textContent.includes(
                level === 'easy' ? 'å…¥é—¨' :
                level === 'medium' ? 'æ™®é€š' :
                level === 'hard' ? 'å›°éš¾' : 'å¤§å¸ˆ'
            )
        );
    });
    restartGame();
}

function restartGame() {
    gameState = 'playing';
    lives = 20;
    gold = 100;
    wave = 1;
    towers = [];
    enemies = [];
    projectiles = [];
    particles = [];
    waveActive = false;
    selectedTower = null;
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('waveBtn').disabled = false;
    document.getElementById('waveBtn').textContent = 'âš”ï¸ å¼€å§‹ä¸‹ä¸€æ³¢';
    updateUI();
    if (audioEnabled) initAudio();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// åˆå§‹åŒ–
createLanterns();
setInterval(createLanterns, 10000);
gameLoop();
updateUI();
</script>
</body>
</html>