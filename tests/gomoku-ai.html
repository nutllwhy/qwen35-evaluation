<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¼ˆæ£‹ - äº”å­æ£‹å¯¹æˆ˜</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --wood-dark: #3d2914;
            --wood-light: #8b6914;
            --wood-mid: #6b4e1c;
            --stone-black: #1a1a1a;
            --stone-white: #f5f5f5;
            --paper: #f8f4e8;
            --ink: #2c2c2c;
            --red-seal: #c41e3a;
            --gold: #d4a574;
        }
        
        body {
            font-family: 'Noto Serif SC', 'Microsoft YaHei', serif;
            background: linear-gradient(135deg, #e8e0d0 0%, #d4c8b8 100%);
            min-height: 100vh;
            color: var(--ink);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        /* æ ‡é¢˜åŒº */
        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px 40px;
            background: linear-gradient(135deg, var(--wood-dark) 0%, var(--wood-mid) 100%);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .header::before,
        .header::after {
            content: 'æ£‹';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 48px;
            color: rgba(255,255,255,0.1);
            font-weight: 700;
        }
        
        .header::before { left: 30px; }
        .header::after { right: 30px; }
        
        .header h1 {
            font-size: 42px;
            font-weight: 700;
            color: var(--gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 8px;
        }
        
        .header .subtitle {
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            margin-top: 5px;
            letter-spacing: 4px;
        }
        
        /* ä¸»å®¹å™¨ */
        .main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            max-width: 1200px;
        }
        
        /* æ£‹ç›˜åŒº */
        .board-section {
            background: linear-gradient(145deg, var(--wood-light) 0%, var(--wood-mid) 50%, var(--wood-dark) 100%);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 
                0 20px 60px rgba(0,0,0,0.4),
                inset 0 2px 4px rgba(255,255,255,0.1);
            position: relative;
        }
        
        .board-section::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 2px solid rgba(212, 165, 116, 0.3);
            border-radius: 12px;
            pointer-events: none;
        }
        
        #canvas {
            display: block;
            border-radius: 8px;
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        
        /* ä¾§è¾¹æ  */
        .sidebar {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            background: var(--paper);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            border: 1px solid rgba(139, 105, 20, 0.2);
        }
        
        .turn-indicator {
            text-align: center;
            padding: 12px;
            background: linear-gradient(135deg, var(--wood-dark), var(--wood-mid));
            border-radius: 8px;
            color: var(--gold);
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 3px;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
        }
        
        .turn-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        /* è®°åˆ† */
        .score-board {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background: rgba(139, 105, 20, 0.1);
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .score-item {
            text-align: center;
        }
        
        .score-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 0 auto 6px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .score-icon.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, var(--stone-black));
        }
        
        .score-icon.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            border: 1px solid #999;
        }
        
        .score-value {
            font-size: 22px;
            font-weight: 700;
            color: var(--wood-dark);
        }
        
        .score-label {
            font-size: 12px;
            color: var(--wood-mid);
            margin-top: 2px;
        }
        
        /* éš¾åº¦é€‰æ‹© */
        .difficulty-section {
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--wood-dark);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .difficulty-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }
        
        .diff-btn {
            padding: 10px;
            border: 2px solid var(--wood-mid);
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            color: var(--wood-dark);
            transition: all 0.3s;
        }
        
        .diff-btn:hover {
            background: rgba(139, 105, 20, 0.1);
        }
        
        .diff-btn.active {
            background: var(--wood-dark);
            color: var(--gold);
            border-color: var(--wood-dark);
        }
        
        /* æŠ€èƒ½é¢æ¿ */
        .skills-panel {
            background: var(--paper);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            border: 1px solid rgba(139, 105, 20, 0.2);
        }
        
        .skill-btn {
            width: 100%;
            padding: 10px 12px;
            margin: 6px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .skill-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .skill-btn:hover:not(:disabled)::before {
            left: 100%;
        }
        
        .skill-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        
        .skill-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: rgba(255,255,255,0.2);
        }
        
        .skill-info {
            flex: 1;
            text-align: left;
        }
        
        .skill-name {
            font-weight: 600;
            font-size: 14px;
        }
        
        .skill-desc {
            font-size: 11px;
            opacity: 0.9;
            margin-top: 2px;
        }
        
        .skill-1 {
            background: linear-gradient(135deg, #8b4513, #a0522d);
            color: #fff;
        }
        
        .skill-2 {
            background: linear-gradient(135deg, #2f4f4f, #3a6b6b);
            color: #fff;
        }
        
        .skill-3 {
            background: linear-gradient(135deg, #4a0080, #6a1b9a);
            color: #fff;
        }
        
        /* æ“ä½œæŒ‰é’® */
        .action-buttons {
            display: flex;
            gap: 8px;
        }
        
        .action-btn {
            flex: 1;
            padding: 10px 8px;
            border: 2px solid var(--wood-mid);
            background: var(--paper);
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            color: var(--wood-dark);
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }
        
        .action-btn:hover {
            background: var(--wood-dark);
            color: var(--gold);
            border-color: var(--wood-dark);
        }
        
        .action-btn .icon {
            font-size: 20px;
        }
        
        /* èƒœè´Ÿå¼¹çª— */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--paper);
            padding: 40px 60px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 3px solid var(--wood-mid);
            position: relative;
        }
        
        .modal-content::before {
            content: 'èƒœ';
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 100px;
            color: var(--red-seal);
            opacity: 0.2;
            font-weight: 700;
        }
        
        .modal h2 {
            font-size: 48px;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .modal h2.win { color: var(--wood-dark); }
        .modal h2.lose { color: var(--red-seal); }
        .modal h2.draw { color: var(--wood-mid); }
        
        .modal-btn {
            margin-top: 25px;
            padding: 15px 40px;
            background: linear-gradient(135deg, var(--wood-dark), var(--wood-mid));
            color: var(--gold);
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .modal-btn:hover {
            transform: scale(1.05);
        }
        
        /* è§„åˆ™è¯´æ˜ */
        .rules-panel {
            background: var(--paper);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            border: 1px solid rgba(139, 105, 20, 0.2);
        }
        
        .rules-content {
            font-size: 13px;
            line-height: 1.8;
            color: var(--wood-mid);
        }
        
        .rules-content strong {
            color: var(--wood-dark);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>å¼ˆ æ£‹</h1>
        <div class="subtitle">äº”å­è¿ç  Â· æ™ºå¤ºå¤©å…ƒ</div>
    </div>
    
    <div class="main-container">
        <div class="board-section">
            <canvas id="canvas" width="672" height="672"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="info-panel">
                <div class="turn-indicator" id="turnIndicator">
                    âš« é»‘æ–¹è½å­
                </div>
                
                <div class="score-board">
                    <div class="score-item">
                        <div class="score-icon black"></div>
                        <div class="score-value" id="blackScore">0</div>
                        <div class="score-label">é»‘æ–¹èƒœåœº</div>
                    </div>
                    <div class="score-item">
                        <div class="score-icon white"></div>
                        <div class="score-value" id="whiteScore">0</div>
                        <div class="score-label">ç™½æ–¹èƒœåœº</div>
                    </div>
                </div>
                
                <div class="difficulty-section">
                    <div class="section-title">ğŸ“œ å¯¹å¼ˆéš¾åº¦</div>
                    <div class="difficulty-buttons">
                        <button class="diff-btn" onclick="setDifficulty('easy')">å…¥é—¨</button>
                        <button class="diff-btn active" onclick="setDifficulty('medium')">æ™®é€š</button>
                        <button class="diff-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
                        <button class="diff-btn" onclick="setDifficulty('expert')">å¤§å¸ˆ</button>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button class="action-btn" onclick="restartGame()">
                        <span class="icon">ğŸ”„</span>
                        <span>æ–°å¼€</span>
                    </button>
                    <button class="action-btn" onclick="undoMove()">
                        <span class="icon">â†©ï¸</span>
                        <span>æ‚”æ£‹</span>
                    </button>
                    <button class="action-btn" onclick="showHint()">
                        <span class="icon">ğŸ’¡</span>
                        <span>æç¤º</span>
                    </button>
                </div>
            </div>
            
            <div class="skills-panel">
                <div class="section-title">âš”ï¸ ç§˜æŠ€</div>
                
                <button class="skill-btn skill-1" id="skill1" onclick="useSkill(1)">
                    <div class="skill-icon">ğŸ¯</div>
                    <div class="skill-info">
                        <div class="skill-name">åŒç®¡é½ä¸‹</div>
                        <div class="skill-desc">æœ¬å›åˆå¯è¿ä¸‹ä¸¤å­</div>
                    </div>
                </button>
                
                <button class="skill-btn skill-2" id="skill2" onclick="useSkill(2)">
                    <div class="skill-icon">ğŸ›¡ï¸</div>
                    <div class="skill-info">
                        <div class="skill-name">åå®¢ä¸ºä¸»</div>
                        <div class="skill-desc">ç§»é™¤å¯¹æ–¹ä¸€æšæ£‹å­</div>
                    </div>
                </button>
                
                <button class="skill-btn skill-3" id="skill3" onclick="useSkill(3)">
                    <div class="skill-icon">âš¡</div>
                    <div class="skill-info">
                        <div class="skill-name">æ—¶å…‰å€’æµ</div>
                        <div class="skill-desc">å›é€€è‡³ä¸‰æ­¥ä¹‹å‰</div>
                    </div>
                </button>
            </div>
            
            <div class="rules-panel">
                <div class="section-title">ğŸ“– å¼ˆç†</div>
                <div class="rules-content">
                    <strong>äº”å­è¿ç ï¼š</strong>æ¨ªã€ç«–ã€æ–œå…ˆæˆäº”å­è€…èƒœã€‚<br>
                    <strong>é»‘å…ˆç™½åï¼š</strong>é»‘æ–¹å…ˆè¡Œï¼Œè½®æµè½å­ã€‚<br>
                    <strong>ç§˜æŠ€ï¼š</strong>æ¯å±€å„é™ç”¨ä¸€æ¬¡ã€‚
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="modal">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <p id="modalDesc"></p>
            <button class="modal-btn" onclick="closeModal()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const BOARD_SIZE = 15;
const CELL_SIZE = 44;
const MARGIN = 28;

let board = [];
let currentPlayer = 1;
let gameOver = false;
let difficulty = 'medium';
let moveHistory = [];
let blackScore = 0;
let whiteScore = 0;
let skillsUsed = { 1: false, 2: false, 3: false };
let extraMove = false;
let removeMode = false;

function initBoard() {
    board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
    currentPlayer = 1;
    gameOver = false;
    moveHistory = [];
    skillsUsed = { 1: false, 2: false, 3: false };
    extraMove = false;
    removeMode = false;
    updateSkillButtons();
    drawBoard();
    updateTurnIndicator();
}

function drawBoard() {
    // æœ¨çº¹èƒŒæ™¯
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#e8c97c');
    gradient.addColorStop(0.5, '#d4a85c');
    gradient.addColorStop(1, '#c4964c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // çº¹ç†æ•ˆæœ
    ctx.fillStyle = 'rgba(139, 105, 20, 0.05)';
    for (let i = 0; i < 50; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const w = Math.random() * 100 + 50;
        const h = Math.random() * 3 + 1;
        ctx.fillRect(x, y, w, h);
    }
    
    // ç½‘æ ¼çº¿
    ctx.strokeStyle = '#4a3728';
    ctx.lineWidth = 1.5;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = MARGIN + i * CELL_SIZE;
        
        ctx.beginPath();
        ctx.moveTo(MARGIN, pos);
        ctx.lineTo(MARGIN + (BOARD_SIZE - 1) * CELL_SIZE, pos);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(pos, MARGIN);
        ctx.lineTo(pos, MARGIN + (BOARD_SIZE - 1) * CELL_SIZE);
        ctx.stroke();
    }
    
    // æ˜Ÿä½
    const stars = [[3,3], [3,7], [3,11], [7,3], [7,7], [7,11], [11,3], [11,7], [11,11]];
    ctx.fillStyle = '#4a3728';
    stars.forEach(([r, c]) => {
        const x = MARGIN + c * CELL_SIZE;
        const y = MARGIN + r * CELL_SIZE;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // æ£‹å­
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] !== 0) {
                drawPiece(r, c, board[r][c]);
            }
        }
    }
    
    // æœ€åè½å­æ ‡è®°
    if (moveHistory.length > 0) {
        const last = moveHistory[moveHistory.length - 1];
        const x = MARGIN + last.c * CELL_SIZE;
        const y = MARGIN + last.r * CELL_SIZE;
        ctx.strokeStyle = '#c41e3a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.stroke();
    }
}

function drawPiece(r, c, player) {
    const x = MARGIN + c * CELL_SIZE;
    const y = MARGIN + r * CELL_SIZE;
    const radius = CELL_SIZE * 0.38;
    
    // é˜´å½±
    ctx.shadowBlur = 8;
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    if (player === 1) {
        // é»‘å­ - æ¼†å™¨è´¨æ„Ÿ
        const grad = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
        grad.addColorStop(0, '#3a3a3a');
        grad.addColorStop(0.3, '#1a1a1a');
        grad.addColorStop(1, '#0a0a0a');
        ctx.fillStyle = grad;
    } else {
        // ç™½å­ - ç‰çŸ³è´¨æ„Ÿ
        const grad = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.3, '#f0f0f0');
        grad.addColorStop(1, '#d0d0d0');
        ctx.fillStyle = grad;
    }
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // é«˜å…‰
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillStyle = player === 1 ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.arc(x - radius/3, y - radius/3, radius/4, 0, Math.PI * 2);
    ctx.fill();
}

// ç‚¹å‡»ä¸‹æ£‹
canvas.addEventListener('click', (e) => {
    if (gameOver) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const c = Math.round((x - MARGIN) / CELL_SIZE);
    const r = Math.round((y - MARGIN) / CELL_SIZE);
    
    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
        if (removeMode && board[r][c] === 2) {
            board[r][c] = 0;
            removeMode = false;
            drawBoard();
            return;
        }
        
        if (board[r][c] === 0 && currentPlayer === 1) {
            makeMove(r, c, 1);
        }
    }
});

function makeMove(r, c, player) {
    board[r][c] = player;
    moveHistory.push({ r, c, player });
    drawBoard();
    
    if (checkWin(r, c, player)) {
        gameOver = true;
        const isWin = player === 1;
        if (isWin) blackScore++;
        else whiteScore++;
        updateScore();
        showModal(isWin ? 'win' : 'lose', isWin ? 'é»‘æ–¹èƒœï¼' : 'ç™½æ–¹èƒœï¼');
        return;
    }
    
    if (checkDraw()) {
        gameOver = true;
        showModal('draw', 'å’Œæ£‹ï¼');
        return;
    }
    
    if (extraMove && player === 1) {
        extraMove = false;
        return;
    }
    
    currentPlayer = 3 - player;
    updateTurnIndicator();
    
    if (currentPlayer === 2) {
        setTimeout(aiMove, 500);
    }
}

function checkWin(r, c, player) {
    const dirs = [[0,1], [1,0], [1,1], [1,-1]];
    for (let [dr, dc] of dirs) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) count++;
            else break;
        }
        for (let i = 1; i < 5; i++) {
            const nr = r - dr * i, nc = c - dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) count++;
            else break;
        }
        if (count >= 5) return true;
    }
    return false;
}

function checkDraw() {
    return board.every(row => row.every(cell => cell !== 0));
}

function aiMove() {
    if (gameOver) return;
    
    let move;
    switch(difficulty) {
        case 'easy': move = getRandomMove(); break;
        case 'medium': move = getGreedyMove(); break;
        case 'hard': move = getMinimaxMove(2); break;
        case 'expert': move = getMinimaxMove(4); break;
    }
    
    if (move) makeMove(move.r, move.c, 2);
}

function getRandomMove() {
    const empty = [];
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            if (board[r][c] === 0) empty.push({ r, c });
    return empty[Math.floor(Math.random() * empty.length)];
}

function getGreedyMove() {
    let best = null, bestScore = -Infinity;
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) {
                const score = evaluate(r, c, 2) + evaluate(r, c, 1) * 0.9;
                if (score > bestScore) { bestScore = score; best = { r, c }; }
            }
        }
    }
    return best;
}

function evaluate(r, c, player) {
    let score = 0;
    const dirs = [[0,1], [1,0], [1,1], [1,-1]];
    for (let [dr, dc] of dirs) {
        let count = 1, blocked = 0;
        for (let i = 1; i < 5; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (board[nr][nc] === player) count++;
                else if (board[nr][nc] !== 0) { blocked++; break; }
                else break;
            } else { blocked++; break; }
        }
        for (let i = 1; i < 5; i++) {
            const nr = r - dr * i, nc = c - dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (board[nr][nc] === player) count++;
                else if (board[nr][nc] !== 0) { blocked++; break; }
                else break;
            } else { blocked++; break; }
        }
        if (count >= 5) score += 100000;
        else if (count === 4 && blocked === 0) score += 10000;
        else if (count === 4 && blocked === 1) score += 1000;
        else if (count === 3 && blocked === 0) score += 1000;
        else if (count === 3 && blocked === 1) score += 100;
        else if (count === 2 && blocked === 0) score += 100;
        else score += count * 10;
    }
    return score;
}

function getMinimaxMove(depth) {
    let best = null, bestScore = -Infinity;
    const moves = getCandidateMoves();
    for (let move of moves) {
        board[move.r][move.c] = 2;
        const score = minimax(depth - 1, false, -Infinity, Infinity);
        board[move.r][move.c] = 0;
        if (score > bestScore) { bestScore = score; best = move; }
    }
    return best || getGreedyMove();
}

function minimax(depth, isMax, alpha, beta) {
    if (depth === 0) return 0;
    const moves = getCandidateMoves();
    if (moves.length === 0) return 0;
    
    if (isMax) {
        let maxScore = -Infinity;
        for (let move of moves) {
            board[move.r][move.c] = 2;
            if (checkWin(move.r, move.c, 2)) { board[move.r][move.c] = 0; return 1000000; }
            const score = minimax(depth - 1, false, alpha, beta);
            board[move.r][move.c] = 0;
            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break;
        }
        return maxScore;
    } else {
        let minScore = Infinity;
        for (let move of moves) {
            board[move.r][move.c] = 1;
            if (checkWin(move.r, move.c, 1)) { board[move.r][move.c] = 0; return -1000000; }
            const score = minimax(depth - 1, true, alpha, beta);
            board[move.r][move.c] = 0;
            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break;
        }
        return minScore;
    }
}

function getCandidateMoves() {
    const moves = [];
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            if (board[r][c] === 0) {
                for (let dr = -2; dr <= 2; dr++)
                    for (let dc = -2; dc <= 2; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                            moves.push({ r, c });
                            break;
                        }
                    }
            }
    return moves.length > 0 ? moves : [{ r: 7, c: 7 }];
}

// æŠ€èƒ½
function useSkill(id) {
    if (gameOver || currentPlayer !== 1 || skillsUsed[id]) return;
    
    switch(id) {
        case 1:
            extraMove = true;
            skillsUsed[1] = true;
            updateSkillButtons();
            break;
        case 2:
            removeMode = true;
            skillsUsed[2] = true;
            updateSkillButtons();
            alert('ç‚¹å‡»ç™½å­å°†å…¶ç§»é™¤');
            break;
        case 3:
            if (moveHistory.length < 3) { alert('æ­¥æ•°ä¸è¶³'); return; }
            for (let i = 0; i < 3; i++) {
                const last = moveHistory.pop();
                if (last) board[last.r][last.c] = 0;
            }
            currentPlayer = 1;
            skillsUsed[3] = true;
            updateSkillButtons();
            drawBoard();
            updateTurnIndicator();
            break;
    }
}

function updateSkillButtons() {
    for (let i = 1; i <= 3; i++) {
        document.getElementById('skill' + i).disabled = skillsUsed[i];
    }
}

function setDifficulty(level) {
    difficulty = level;
    document.querySelectorAll('.diff-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.includes(
            level === 'easy' ? 'å…¥é—¨' :
            level === 'medium' ? 'æ™®é€š' :
            level === 'hard' ? 'å›°éš¾' : 'å¤§å¸ˆ'
        ));
    });
    restartGame();
}

function restartGame() {
    initBoard();
}

function undoMove() {
    if (moveHistory.length < 2 || gameOver) return;
    for (let i = 0; i < 2; i++) {
        const last = moveHistory.pop();
        if (last) board[last.r][last.c] = 0;
    }
    currentPlayer = 1;
    drawBoard();
    updateTurnIndicator();
}

function showHint() {
    if (gameOver || currentPlayer !== 1) return;
    let best = null, bestScore = -Infinity;
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            if (board[r][c] === 0) {
                const score = evaluate(r, c, 1);
                if (score > bestScore) { bestScore = score; best = { r, c }; }
            }
    if (best) {
        const x = MARGIN + best.c * CELL_SIZE;
        const y = MARGIN + best.r * CELL_SIZE;
        ctx.strokeStyle = '#c41e3a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, CELL_SIZE * 0.4, 0, Math.PI * 2);
        ctx.stroke();
        setTimeout(drawBoard, 1500);
    }
}

function updateTurnIndicator() {
    const el = document.getElementById('turnIndicator');
    if (currentPlayer === 1) {
        el.innerHTML = 'âš« é»‘æ–¹è½å­';
        el.style.background = 'linear-gradient(135deg, #2a2a2a, #1a1a1a)';
    } else {
        el.innerHTML = 'âšª ç™½æ–¹æ€è€ƒä¸­...';
        el.style.background = 'linear-gradient(135deg, #5a5a5a, #3a3a3a)';
    }
}

function updateScore() {
    document.getElementById('blackScore').textContent = blackScore;
    document.getElementById('whiteScore').textContent = whiteScore;
}

function showModal(type, message) {
    document.getElementById('modal').style.display = 'flex';
    const title = document.getElementById('modalTitle');
    title.textContent = message;
    title.className = type;
    document.getElementById('modalDesc').textContent = type === 'win' ? 'äº”å­è¿ç ï¼Œå¦™æ‰‹å¤©æˆ' :
                                                      type === 'lose' ? 'æ£‹å·®ä¸€ç€ï¼Œå†æ¥å†å‰' : 'å¹³åˆ†ç§‹è‰²ï¼Œä¸åˆ†ä¼¯ä»²';
}

function closeModal() {
    document.getElementById('modal').style.display = 'none';
    restartGame();
}

initBoard();
</script>
</body>
</html>