<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¼ˆæ£‹ - äº”å­æ£‹å¯¹æˆ˜</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --wood-dark: #8b1a1a;
            --wood-light: #d4a574;
            --wood-mid: #b8860b;
            --stone-black: #1a1a1a;
            --stone-white: #fff8f0;
            --paper: #fff5e6;
            --ink: #8b0000;
            --red-seal: #dc143c;
            --gold: #ffd700;
            --festive-red: #c41e3a;
            --festive-gold: #ffd700;
        }
        
        body {
            font-family: 'Noto Serif SC', 'Microsoft YaHei', serif;
            background: linear-gradient(145deg, #8b0000 0%, #c41e3a 30%, #dc143c 70%, #8b1a1a 100%);
            min-height: 100vh;
            color: var(--ink);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255,215,0,0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255,215,0,0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        /* æ ‡é¢˜åŒº - æ–°å¹´å–œåº†é£æ ¼ */
        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 25px 50px;
            background: linear-gradient(135deg, #c41e3a 0%, #8b1a1a 50%, #dc143c 100%);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(196, 30, 58, 0.4), inset 0 2px 4px rgba(255,215,0,0.3);
            position: relative;
            border: 3px solid #ffd700;
        }
        
        .header::before,
        .header::after {
            content: 'ğŸ§§';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 40px;
        }
        
        .header::before { left: 25px; }
        .header::after { right: 25px; }
        
        .header h1 {
            font-size: 48px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 
                0 0 10px rgba(255,215,0,0.5),
                2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 12px;
        }
        
        .header .subtitle {
            font-size: 16px;
            color: #fff;
            margin-top: 8px;
            letter-spacing: 6px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        /* é£˜è½çš„èŠ±ç“£è£…é¥° */
        .petal {
            position: fixed;
            top: -50px;
            font-size: 24px;
            animation: fall linear infinite;
            pointer-events: none;
            z-index: 1;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }
        
        /* ä¸»å®¹å™¨ */
        .main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            max-width: 1200px;
            position: relative;
            z-index: 2;
        }
        
        .header {
            position: relative;
            z-index: 2;
        }
        
        /* æ£‹ç›˜åŒº - æ–°å¹´å–œåº†ç‰ˆ */
        .board-section {
            background: linear-gradient(145deg, #dc143c 0%, #8b1a1a 50%, #8b0000 100%);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 
                0 20px 60px rgba(139, 0, 0, 0.5),
                inset 0 2px 4px rgba(255,215,0,0.2);
            position: relative;
            border: 3px solid #ffd700;
        }
        
        .board-section::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 2px solid rgba(212, 165, 116, 0.3);
            border-radius: 12px;
            pointer-events: none;
        }
        
        #canvas {
            display: block;
            border-radius: 8px;
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        
        /* ä¾§è¾¹æ  */
        .sidebar {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            background: linear-gradient(145deg, #fff5e6 0%, #ffe4cc 100%);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(139, 0, 0, 0.2);
            border: 2px solid #ffd700;
        }
        
        .turn-indicator {
            text-align: center;
            padding: 12px;
            background: linear-gradient(135deg, #c41e3a, #8b1a1a);
            border-radius: 8px;
            color: #ffd700;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 3px;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
            border: 2px solid #ffd700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .turn-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        /* è®°åˆ† */
        .score-board {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background: rgba(139, 105, 20, 0.1);
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .score-item {
            text-align: center;
        }
        
        .score-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 0 auto 6px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .score-icon.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, var(--stone-black));
        }
        
        .score-icon.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            border: 1px solid #999;
        }
        
        .score-value {
            font-size: 22px;
            font-weight: 700;
            color: var(--wood-dark);
        }
        
        .score-label {
            font-size: 12px;
            color: var(--wood-mid);
            margin-top: 2px;
        }
        
        /* éš¾åº¦é€‰æ‹© */
        .difficulty-section {
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--wood-dark);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .difficulty-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }
        
        .diff-btn {
            padding: 10px;
            border: 2px solid var(--wood-mid);
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            color: var(--wood-dark);
            transition: all 0.3s;
        }
        
        .diff-btn:hover {
            background: rgba(139, 105, 20, 0.1);
        }
        
        .diff-btn.active {
            background: var(--wood-dark);
            color: var(--gold);
            border-color: var(--wood-dark);
        }
        
        /* æŠ€èƒ½é¢æ¿ */
        .skills-panel {
            background: linear-gradient(145deg, #fff5e6 0%, #ffe4cc 100%);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(139, 0, 0, 0.2);
            border: 2px solid #ffd700;
        }
        
        .skill-btn {
            width: 100%;
            padding: 10px 12px;
            margin: 6px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .skill-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .skill-btn:hover:not(:disabled)::before {
            left: 100%;
        }
        
        .skill-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        
        .skill-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background: rgba(255,255,255,0.2);
        }
        
        .skill-info {
            flex: 1;
            text-align: left;
        }
        
        .skill-name {
            font-weight: 600;
            font-size: 14px;
        }
        
        .skill-desc {
            font-size: 11px;
            opacity: 0.9;
            margin-top: 2px;
        }
        
        .skill-1 {
            background: linear-gradient(135deg, #8b4513, #a0522d);
            color: #fff;
        }
        
        .skill-2 {
            background: linear-gradient(135deg, #2f4f4f, #3a6b6b);
            color: #fff;
        }
        
        .skill-3 {
            background: linear-gradient(135deg, #4a0080, #6a1b9a);
            color: #fff;
        }
        
        /* æ“ä½œæŒ‰é’® */
        .action-buttons {
            display: flex;
            gap: 8px;
        }
        
        .action-btn {
            flex: 1;
            padding: 10px 8px;
            border: 2px solid var(--wood-mid);
            background: var(--paper);
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            color: var(--wood-dark);
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }
        
        .action-btn:hover {
            background: var(--wood-dark);
            color: var(--gold);
            border-color: var(--wood-dark);
        }
        
        .action-btn .icon {
            font-size: 20px;
        }
        
        /* èƒœè´Ÿå¼¹çª— - æ–°å¹´å–œåº†ç‰ˆ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 0, 0, 0.85);
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(145deg, #fff5e6 0%, #ffe4cc 100%);
            padding: 50px 70px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 
                0 20px 60px rgba(196, 30, 58, 0.5),
                0 0 100px rgba(255, 215, 0, 0.3),
                inset 0 0 30px rgba(255, 215, 0, 0.2);
            border: 4px solid #ffd700;
            position: relative;
            overflow: hidden;
        }
        
        .modal-content::before {
            content: 'ğŸŠ';
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 50px;
            animation: bounce 1s infinite;
        }
        
        .modal-content::after {
            content: 'ğŸŠ';
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 50px;
            animation: bounce 1s infinite 0.5s;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.1); }
        }
        
        .modal h2 {
            font-size: 56px;
            margin-bottom: 15px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .modal h2.win { 
            color: #c41e3a;
            text-shadow: 
                0 0 20px rgba(196, 30, 58, 0.5),
                2px 2px 4px rgba(0,0,0,0.2);
        }
        .modal h2.lose { color: #666; }
        .modal h2.draw { color: #b8860b; }
        
        .modal-desc {
            font-size: 20px;
            color: #8b4513;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .modal-blessing {
            font-size: 20px;
            color: #c41e3a;
            margin: 15px 0 30px;
            padding: 14px 28px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.15));
            border-radius: 25px;
            border: 2px solid #ffd700;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            text-align: center;
        }
        
        .modal-btn {
            margin-top: 20px;
            padding: 18px 50px;
            background: linear-gradient(135deg, #c41e3a, #8b1a1a);
            color: #ffd700;
            border: 3px solid #ffd700;
            border-radius: 30px;
            font-family: inherit;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(196, 30, 58, 0.4);
        }
        
        .modal-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 8px 30px rgba(196, 30, 58, 0.6);
            background: linear-gradient(135deg, #dc143c, #c41e3a);
        }
        
        /* çƒŸèŠ±æ•ˆæœ */
        .firework {
            position: fixed;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: explode 1s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }
        
        /* è§„åˆ™è¯´æ˜ */
        .rules-panel {
            background: linear-gradient(145deg, #fff5e6 0%, #ffe4cc 100%);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(139, 0, 0, 0.2);
            border: 2px solid #ffd700;
        }
        
        .rules-content {
            font-size: 13px;
            line-height: 1.8;
            color: var(--wood-mid);
        }
        
        .rules-content strong {
            color: var(--wood-dark);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>å¼ˆ æ£‹</h1>
        <div class="subtitle">äº”å­è¿ç  Â· æ™ºå¤ºå¤©å…ƒ</div>
        <button id="audioToggle" onclick="toggleAudio()" style="position: absolute; top: 15px; right: 15px; background: rgba(255,255,255,0.2); border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 18px;">ğŸ”Š</button>
    </div>
    
    <div class="main-container">
        <div class="board-section">
            <canvas id="canvas" width="672" height="672"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="info-panel">
                <div class="turn-indicator" id="turnIndicator">
                    âš« é»‘æ–¹è½å­
                </div>
                
                <div class="score-board">
                    <div class="score-item">
                        <div class="score-icon black"></div>
                        <div class="score-value" id="blackScore">0</div>
                        <div class="score-label">é»‘æ–¹èƒœåœº</div>
                    </div>
                    <div class="score-item">
                        <div class="score-icon white"></div>
                        <div class="score-value" id="whiteScore">0</div>
                        <div class="score-label">ç™½æ–¹èƒœåœº</div>
                    </div>
                </div>
                
                <div class="difficulty-section">
                    <div class="section-title">ğŸ“œ å¯¹å¼ˆéš¾åº¦</div>
                    <div class="difficulty-buttons">
                        <button class="diff-btn" onclick="setDifficulty('easy')">å…¥é—¨</button>
                        <button class="diff-btn active" onclick="setDifficulty('medium')">æ™®é€š</button>
                        <button class="diff-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
                        <button class="diff-btn" onclick="setDifficulty('expert')">å¤§å¸ˆ</button>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button class="action-btn" onclick="restartGame()">
                        <span class="icon">ğŸ”„</span>
                        <span>æ–°å¼€</span>
                    </button>
                    <button class="action-btn" onclick="undoMove()">
                        <span class="icon">â†©ï¸</span>
                        <span>æ‚”æ£‹</span>
                    </button>
                    <button class="action-btn" onclick="showHint()">
                        <span class="icon">ğŸ’¡</span>
                        <span>æç¤º</span>
                    </button>
                </div>
            </div>
            
            <div class="skills-panel">
                <div class="section-title">âš”ï¸ ç§˜æŠ€</div>
                
                <button class="skill-btn skill-1" id="skill1" onclick="useSkill(1)">
                    <div class="skill-icon">ğŸ¯</div>
                    <div class="skill-info">
                        <div class="skill-name">åŒç®¡é½ä¸‹</div>
                        <div class="skill-desc">æœ¬å›åˆå¯è¿ä¸‹ä¸¤å­</div>
                    </div>
                </button>
                
                <button class="skill-btn skill-2" id="skill2" onclick="useSkill(2)">
                    <div class="skill-icon">ğŸ›¡ï¸</div>
                    <div class="skill-info">
                        <div class="skill-name">åå®¢ä¸ºä¸»</div>
                        <div class="skill-desc">ç§»é™¤å¯¹æ–¹ä¸€æšæ£‹å­</div>
                    </div>
                </button>
                
                <button class="skill-btn skill-3" id="skill3" onclick="useSkill(3)">
                    <div class="skill-icon">âš¡</div>
                    <div class="skill-info">
                        <div class="skill-name">æ—¶å…‰å€’æµ</div>
                        <div class="skill-desc">å›é€€è‡³ä¸‰æ­¥ä¹‹å‰</div>
                    </div>
                </button>
            </div>
            
            <div class="rules-panel">
                <div class="section-title">ğŸ“– å¼ˆç†</div>
                <div class="rules-content">
                    <strong>äº”å­è¿ç ï¼š</strong>æ¨ªã€ç«–ã€æ–œå…ˆæˆäº”å­è€…èƒœã€‚<br>
                    <strong>é»‘å…ˆç™½åï¼š</strong>é»‘æ–¹å…ˆè¡Œï¼Œè½®æµè½å­ã€‚<br>
                    <strong>ç§˜æŠ€ï¼š</strong>æ¯å±€å„é™ç”¨ä¸€æ¬¡ã€‚<br>
                    <strong>ğŸ”Š éŸ³æ•ˆï¼š</strong>ç‚¹å‡»å³ä¸Šè§’æŒ‰é’®å¼€å…³éŸ³æ•ˆã€‚
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="modal">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <p class="modal-desc" id="modalDesc"></p>
            <p class="modal-blessing" id="modalBlessing"></p>
            <button class="modal-btn" onclick="closeModal()">ğŸ® å†æ¥ä¸€å±€</button>
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// ==================== éŸ³é¢‘ç³»ç»Ÿ ====================
let audioEnabled = true;
let audioContext = null;
let bgmOscillators = [];
let bgmGainNode = null;
let isBgmPlaying = false;

// åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ - å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’åè°ƒç”¨
function initAudio() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    // å¦‚æœéŸ³é¢‘ä¸Šä¸‹æ–‡è¢«æš‚åœï¼Œæ¢å¤å®ƒ
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
    // åˆå§‹åŒ–åå¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹
    if (!isBgmPlaying && audioEnabled) {
        startBGM();
    }
}

function toggleAudio() {
    audioEnabled = !audioEnabled;
    const btn = document.getElementById('audioToggle');
    btn.textContent = audioEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
    btn.style.opacity = audioEnabled ? '1' : '0.5';
    if (audioEnabled) {
        initAudio();
        startBGM();
        playTestSound();
    } else {
        stopBGM();
    }
}

// èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ - å–œåº†çš„ä¸­å›½é£æ—‹å¾‹
const bgmMelody = [
    // ç¬¬ä¸€ä¹å¥ - å–œåº†å¼€åœº
    { note: 523.25, duration: 0.25 }, // C5
    { note: 523.25, duration: 0.25 }, // C5
    { note: 587.33, duration: 0.25 }, // D5
    { note: 659.25, duration: 0.5 },  // E5
    { note: 587.33, duration: 0.25 }, // D5
    { note: 523.25, duration: 0.25 }, // C5
    { note: 587.33, duration: 0.5 },  // D5
    // ç¬¬äºŒä¹å¥
    { note: 659.25, duration: 0.25 }, // E5
    { note: 659.25, duration: 0.25 }, // E5
    { note: 698.46, duration: 0.25 }, // F5
    { note: 783.99, duration: 0.5 },  // G5
    { note: 698.46, duration: 0.25 }, // F5
    { note: 659.25, duration: 0.25 }, // E5
    { note: 587.33, duration: 0.5 },  // D5
    // ç¬¬ä¸‰ä¹å¥ - é«˜æ½®
    { note: 783.99, duration: 0.25 }, // G5
    { note: 783.99, duration: 0.25 }, // G5
    { note: 880.00, duration: 0.25 }, // A5
    { note: 783.99, duration: 0.25 }, // G5
    { note: 698.46, duration: 0.25 }, // F5
    { note: 659.25, duration: 0.25 }, // E5
    { note: 587.33, duration: 0.5 },  // D5
    // ç»“å°¾
    { note: 659.25, duration: 0.25 }, // E5
    { note: 587.33, duration: 0.25 }, // D5
    { note: 523.25, duration: 0.5 },  // C5
    { note: 0, duration: 0.25 },      // ä¼‘æ­¢
    { note: 523.25, duration: 0.75 }, // C5 é•¿éŸ³
];

let bgmIndex = 0;
let nextNoteTime = 0;
let bgmTimer = null;

function startBGM() {
    if (!audioEnabled || !audioContext || isBgmPlaying) return;
    
    isBgmPlaying = true;
    bgmIndex = 0;
    nextNoteTime = audioContext.currentTime;
    
    // åˆ›å»ºèƒŒæ™¯éŸ³ä¹å¢ç›ŠèŠ‚ç‚¹
    bgmGainNode = audioContext.createGain();
    bgmGainNode.connect(audioContext.destination);
    bgmGainNode.gain.value = 0.15; // èƒŒæ™¯éŸ³é‡è¾ƒå°
    
    scheduleNotes();
}

function scheduleNotes() {
    if (!isBgmPlaying || !audioEnabled) return;
    
    const currentTime = audioContext.currentTime;
    
    // æå‰è°ƒåº¦æ¥ä¸‹æ¥çš„éŸ³ç¬¦
    while (nextNoteTime < currentTime + 0.5) {
        const noteData = bgmMelody[bgmIndex];
        
        if (noteData.note > 0) {
            // ä¸»éŸ³
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(bgmGainNode);
            
            osc.frequency.value = noteData.note;
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0, nextNoteTime);
            gain.gain.linearRampToValueAtTime(0.3, nextNoteTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + noteData.duration * 0.8);
            
            osc.start(nextNoteTime);
            osc.stop(nextNoteTime + noteData.duration);
            
            // å…«åº¦éŸ³å¢åŠ ä¸°æ»¡åº¦
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            osc2.connect(gain2);
            gain2.connect(bgmGainNode);
            
            osc2.frequency.value = noteData.note / 2;
            osc2.type = 'triangle';
            gain2.gain.value = 0.1;
            
            osc2.start(nextNoteTime);
            osc2.stop(nextNoteTime + noteData.duration);
        }
        
        nextNoteTime += noteData.duration;
        bgmIndex = (bgmIndex + 1) % bgmMelody.length;
    }
    
    bgmTimer = setTimeout(scheduleNotes, 100);
}

function stopBGM() {
    isBgmPlaying = false;
    if (bgmTimer) {
        clearTimeout(bgmTimer);
        bgmTimer = null;
    }
    if (bgmGainNode) {
        bgmGainNode.disconnect();
        bgmGainNode = null;
    }
}

// æµ‹è¯•éŸ³æ•ˆ
function playTestSound() {
    if (!audioEnabled || !audioContext) return;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.frequency.value = 880;
    gain.gain.setValueAtTime(0.1, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
}

// æ’­æ”¾è½å­å£° - æ¸…è„†çš„çŸ³å­æ•²å‡»å£°
function playPlaceSound(player) {
    if (!audioEnabled || !audioContext) return;
    
    const t = audioContext.currentTime;
    
    // ä¸»éŸ³ - æ¸…è„†çš„æ•²å‡»
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    // é»‘å­ç¨ä½ï¼Œç™½å­ç¨é«˜ï¼Œéƒ½å¾ˆæ¸…è„†
    const baseFreq = player === 1 ? 800 : 1200;
    osc.frequency.setValueAtTime(baseFreq, t);
    osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, t + 0.08);
    osc.type = 'triangle';
    
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.5, t + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
    
    osc.start(t);
    osc.stop(t + 0.15);
    
    // æ³›éŸ³ - å¢åŠ æ¸…è„†æ„Ÿ
    const osc2 = audioContext.createOscillator();
    const gain2 = audioContext.createGain();
    osc2.connect(gain2);
    gain2.connect(audioContext.destination);
    
    osc2.frequency.setValueAtTime(baseFreq * 2.5, t);
    osc2.type = 'sine';
    gain2.gain.setValueAtTime(0, t);
    gain2.gain.linearRampToValueAtTime(0.2, t + 0.003);
    gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
    
    osc2.start(t);
    osc2.stop(t + 0.1);
}

// æ’­æ”¾èƒœåˆ©éŸ³æ•ˆ - æ¬¢å¿«çš„å’Œå¼¦
function playWinSound() {
    if (!audioEnabled || !audioContext) return;
    
    const t = audioContext.currentTime;
    const notes = [523.25, 659.25, 783.99, 1046.50]; // C-E-G-C
    
    notes.forEach((freq, i) => {
        // ä¸»éŸ³
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.frequency.value = freq;
        osc.type = 'sine';
        
        const startTime = t + i * 0.12;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.4, startTime + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.8);
        
        osc.start(startTime);
        osc.stop(startTime + 1);
        
        // å…«åº¦éŸ³å¢åŠ ä¸°æ»¡åº¦
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        
        osc2.frequency.value = freq * 2;
        osc2.type = 'sine';
        gain2.gain.setValueAtTime(0, startTime);
        gain2.gain.linearRampToValueAtTime(0.15, startTime + 0.03);
        gain2.gain.exponentialRampToValueAtTime(0.01, startTime + 0.6);
        
        osc2.start(startTime);
        osc2.stop(startTime + 0.8);
    });
}

// æ’­æ”¾å¤±è´¥éŸ³æ•ˆ
function playLoseSound() {
    if (!audioEnabled || !audioContext) return;
    
    const t = audioContext.currentTime;
    const notes = [349.23, 293.66, 261.63]; // F-D-C
    
    notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.frequency.value = freq;
        osc.type = 'triangle';
        
        const startTime = t + i * 0.2;
        gain.gain.setValueAtTime(0.3, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.5);
        
        osc.start(startTime);
        osc.stop(startTime + 0.6);
    });
}

// æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
function playSkillSound() {
    if (!audioEnabled || !audioContext) return;
    
    const t = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.frequency.setValueAtTime(600, t);
    osc.frequency.linearRampToValueAtTime(1200, t + 0.15);
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.3, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
    
    osc.start(t);
    osc.stop(t + 0.5);
}

const BOARD_SIZE = 15;
const CELL_SIZE = 44;
const MARGIN = 28;

let board = [];
let currentPlayer = 1;
let gameOver = false;
let difficulty = 'medium';
let moveHistory = [];
let blackScore = 0;
let whiteScore = 0;
let skillsUsed = { 1: false, 2: false, 3: false };
let extraMove = false;
let removeMode = false;

function initBoard() {
    board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
    currentPlayer = 1;
    gameOver = false;
    moveHistory = [];
    skillsUsed = { 1: false, 2: false, 3: false };
    extraMove = false;
    removeMode = false;
    updateSkillButtons();
    drawBoard();
    updateTurnIndicator();
    // åˆ›å»ºæ–°å¹´é£˜è½è£…é¥°
    createPetals();
    // å®šæœŸåˆ›å»ºæ–°è£…é¥°
    setInterval(createPetals, 8000);
}

function drawBoard() {
    // æœ¨çº¹èƒŒæ™¯
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#e8c97c');
    gradient.addColorStop(0.5, '#d4a85c');
    gradient.addColorStop(1, '#c4964c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // çº¹ç†æ•ˆæœ
    ctx.fillStyle = 'rgba(139, 105, 20, 0.05)';
    for (let i = 0; i < 50; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const w = Math.random() * 100 + 50;
        const h = Math.random() * 3 + 1;
        ctx.fillRect(x, y, w, h);
    }
    
    // ç½‘æ ¼çº¿
    ctx.strokeStyle = '#4a3728';
    ctx.lineWidth = 1.5;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = MARGIN + i * CELL_SIZE;
        
        ctx.beginPath();
        ctx.moveTo(MARGIN, pos);
        ctx.lineTo(MARGIN + (BOARD_SIZE - 1) * CELL_SIZE, pos);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(pos, MARGIN);
        ctx.lineTo(pos, MARGIN + (BOARD_SIZE - 1) * CELL_SIZE);
        ctx.stroke();
    }
    
    // æ˜Ÿä½
    const stars = [[3,3], [3,7], [3,11], [7,3], [7,7], [7,11], [11,3], [11,7], [11,11]];
    ctx.fillStyle = '#4a3728';
    stars.forEach(([r, c]) => {
        const x = MARGIN + c * CELL_SIZE;
        const y = MARGIN + r * CELL_SIZE;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // æ£‹å­
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] !== 0) {
                drawPiece(r, c, board[r][c]);
            }
        }
    }
    
    // æœ€åè½å­æ ‡è®°
    if (moveHistory.length > 0) {
        const last = moveHistory[moveHistory.length - 1];
        const x = MARGIN + last.c * CELL_SIZE;
        const y = MARGIN + last.r * CELL_SIZE;
        ctx.strokeStyle = '#c41e3a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.stroke();
    }
}

function drawPiece(r, c, player) {
    const x = MARGIN + c * CELL_SIZE;
    const y = MARGIN + r * CELL_SIZE;
    const radius = CELL_SIZE * 0.38;
    
    // é˜´å½±
    ctx.shadowBlur = 8;
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    if (player === 1) {
        // é»‘å­ - æ¼†å™¨è´¨æ„Ÿ
        const grad = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
        grad.addColorStop(0, '#3a3a3a');
        grad.addColorStop(0.3, '#1a1a1a');
        grad.addColorStop(1, '#0a0a0a');
        ctx.fillStyle = grad;
    } else {
        // ç™½å­ - ç‰çŸ³è´¨æ„Ÿ
        const grad = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.3, '#f0f0f0');
        grad.addColorStop(1, '#d0d0d0');
        ctx.fillStyle = grad;
    }
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    // é«˜å…‰
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillStyle = player === 1 ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.arc(x - radius/3, y - radius/3, radius/4, 0, Math.PI * 2);
    ctx.fill();
}

// ç‚¹å‡»ä¸‹æ£‹
canvas.addEventListener('click', async (e) => {
    if (gameOver) return;
    
    // é¦–æ¬¡äº¤äº’åˆå§‹åŒ–éŸ³é¢‘å¹¶æ¢å¤ä¸Šä¸‹æ–‡
    initAudio();
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    // é¦–æ¬¡ç‚¹å‡»å¼€å§‹èƒŒæ™¯éŸ³ä¹
    if (!isBgmPlaying && audioEnabled) {
        startBGM();
    }
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const c = Math.round((x - MARGIN) / CELL_SIZE);
    const r = Math.round((y - MARGIN) / CELL_SIZE);
    
    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
        if (removeMode && board[r][c] === 2) {
            board[r][c] = 0;
            removeMode = false;
            drawBoard();
            return;
        }
        
        if (board[r][c] === 0 && currentPlayer === 1) {
            makeMove(r, c, 1);
        }
    }
});

function makeMove(r, c, player) {
    board[r][c] = player;
    moveHistory.push({ r, c, player });
    playPlaceSound(player);
    drawBoard();
    
    if (checkWin(r, c, player)) {
        gameOver = true;
        const isWin = player === 1;
        if (isWin) blackScore++;
        else whiteScore++;
        updateScore();
        showModal(isWin ? 'win' : 'lose', isWin ? 'ğŸ‰ é»‘æ–¹è·èƒœï¼' : 'ğŸ¤ ç™½æ–¹è·èƒœï¼');
        return;
    }
    
    if (checkDraw()) {
        gameOver = true;
        showModal('draw', 'å’Œæ£‹ï¼');
        return;
    }
    
    if (extraMove && player === 1) {
        extraMove = false;
        return;
    }
    
    currentPlayer = 3 - player;
    updateTurnIndicator();
    
    if (currentPlayer === 2) {
        setTimeout(aiMove, 500);
    }
}

function checkWin(r, c, player) {
    const dirs = [[0,1], [1,0], [1,1], [1,-1]];
    for (let [dr, dc] of dirs) {
        let count = 1;
        for (let i = 1; i < 5; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) count++;
            else break;
        }
        for (let i = 1; i < 5; i++) {
            const nr = r - dr * i, nc = c - dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) count++;
            else break;
        }
        if (count >= 5) return true;
    }
    return false;
}

function checkDraw() {
    return board.every(row => row.every(cell => cell !== 0));
}

function aiMove() {
    if (gameOver) return;
    
    let move;
    switch(difficulty) {
        case 'easy': move = getRandomMove(); break;
        case 'medium': move = getGreedyMove(); break;
        case 'hard': move = getMinimaxMove(2); break;
        case 'expert': move = getMinimaxMove(4); break;
    }
    
    if (move) makeMove(move.r, move.c, 2);
}

function getRandomMove() {
    const empty = [];
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            if (board[r][c] === 0) empty.push({ r, c });
    return empty[Math.floor(Math.random() * empty.length)];
}

function getGreedyMove() {
    let best = null, bestScore = -Infinity;
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) {
                const score = evaluate(r, c, 2) + evaluate(r, c, 1) * 0.9;
                if (score > bestScore) { bestScore = score; best = { r, c }; }
            }
        }
    }
    return best;
}

// å¢å¼ºç‰ˆè¯„ä¼°å‡½æ•° - è€ƒè™‘æ›´å¤šæ£‹å‹å’Œä½ç½®ä»·å€¼
function evaluate(r, c, player) {
    let score = 0;
    const dirs = [[0,1], [1,0], [1,1], [1,-1]];
    
    for (let [dr, dc] of dirs) {
        // è·å–è¯¥æ–¹å‘çš„æ£‹å­åˆ†å¸ƒ
        let line = [];
        for (let i = -4; i <= 4; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                line.push(board[nr][nc]);
            } else {
                line.push(-1); // è¾¹ç•Œ
            }
        }
        
        // ä¸­å¿ƒä½ç½®æ˜¯4ï¼Œæ£€æŸ¥ä»¥ä¸­å¿ƒçš„å„ç§æ¨¡å¼
        const patterns = [
            { pattern: [0, player, player, player, player, 0], score: 10000 }, // æ´»å››
            { pattern: [0, player, player, player, 0], score: 1000 }, // æ´»ä¸‰
            { pattern: [0, player, player, 0, player, 0], score: 800 }, // è·³æ´»ä¸‰
            { pattern: [0, player, player, 0], score: 100 }, // æ´»äºŒ
            { pattern: [0, player, 0, player, 0], score: 50 }, // è·³æ´»äºŒ
            { pattern: [player, player, player, player, player], score: 100000 }, // äº”è¿
            { pattern: [-1, player, player, player, player, 0], score: 5000 }, // å†²å››
            { pattern: [0, player, player, player, player, -1], score: 5000 }, // å†²å››
        ];
        
        for (let { pattern, score: s } of patterns) {
            for (let offset = 0; offset <= line.length - pattern.length; offset++) {
                let match = true;
                for (let i = 0; i < pattern.length; i++) {
                    if (line[offset + i] !== pattern[i]) {
                        match = false;
                        break;
                    }
                }
                if (match) score += s;
            }
        }
        
        // è¿å­æ•°è¯„ä¼°
        let count = 1, blocked = 0, space = 0;
        for (let i = 1; i < 5; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (board[nr][nc] === player) count++;
                else if (board[nr][nc] === 0) { space++; break; }
                else { blocked++; break; }
            } else { blocked++; break; }
        }
        for (let i = 1; i < 5; i++) {
            const nr = r - dr * i, nc = c - dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (board[nr][nc] === player) count++;
                else if (board[nr][nc] === 0) { space++; break; }
                else { blocked++; break; }
            } else { blocked++; break; }
        }
        
        // æ ¹æ®è¿å­æ•°å’Œå°å µæƒ…å†µè¯„åˆ†
        if (count >= 5) score += 100000;
        else if (count === 4 && blocked === 0) score += 10000; // æ´»å››
        else if (count === 4 && blocked === 1) score += 5000;  // å†²å››
        else if (count === 3 && blocked === 0) score += 1000;  // æ´»ä¸‰
        else if (count === 3 && blocked === 1) score += 100;   // çœ ä¸‰
        else if (count === 2 && blocked === 0) score += 50;    // æ´»äºŒ
    }
    
    // ä½ç½®ä»·å€¼ - ä¸­å¿ƒä½ç½®æ›´æœ‰ä»·å€¼
    const centerDist = Math.abs(r - 7) + Math.abs(c - 7);
    score += (14 - centerDist) * 5;
    
    return score;
}

// å¢å¼ºç‰ˆMinimax - ä½¿ç”¨è¯„ä¼°å‡½æ•°ä½œä¸ºå¶å­èŠ‚ç‚¹å€¼
function getMinimaxMove(depth) {
    let best = null, bestScore = -Infinity;
    const moves = getSortedCandidateMoves();
    
    // é™åˆ¶æœç´¢èŒƒå›´ä»¥æé«˜æ€§èƒ½
    const topMoves = moves.slice(0, 12);
    
    for (let move of topMoves) {
        board[move.r][move.c] = 2;
        // æ£€æŸ¥æ˜¯å¦ç›´æ¥è·èƒœ
        if (checkWin(move.r, move.c, 2)) {
            board[move.r][move.c] = 0;
            return move;
        }
        const score = minimax(depth - 1, false, -Infinity, Infinity, move.r, move.c);
        board[move.r][move.c] = 0;
        if (score > bestScore) { bestScore = score; best = move; }
    }
    return best || getGreedyMove();
}

// å¢å¼ºç‰ˆMinimax - å¸¦æœ‰æ·±åº¦é™åˆ¶å’Œè¯„ä¼°å‡½æ•°
function minimax(depth, isMax, alpha, beta, lastR, lastC) {
    // åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œè¯„ä¼°å½“å‰å±€é¢
    if (depth === 0) {
        return evaluateBoard();
    }
    
    const moves = getSortedCandidateMoves();
    if (moves.length === 0) return 0;
    
    // é™åˆ¶åˆ†æ”¯å› å­
    const limitedMoves = moves.slice(0, 8);
    
    if (isMax) {
        let maxScore = -Infinity;
        for (let move of limitedMoves) {
            board[move.r][move.c] = 2;
            // æ£€æŸ¥è·èƒœ
            if (checkWin(move.r, move.c, 2)) {
                board[move.r][move.c] = 0;
                return 10000000; // AIè·èƒœï¼Œæé«˜åˆ†æ•°
            }
            const score = minimax(depth - 1, false, alpha, beta, move.r, move.c);
            board[move.r][move.c] = 0;
            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break; // Alpha-Betaå‰ªæ
        }
        return maxScore;
    } else {
        let minScore = Infinity;
        for (let move of limitedMoves) {
            board[move.r][move.c] = 1;
            // æ£€æŸ¥ç©å®¶è·èƒœï¼ˆéœ€è¦é˜»æ­¢ï¼‰
            if (checkWin(move.r, move.c, 1)) {
                board[move.r][move.c] = 0;
                return -10000000; // ç©å®¶è·èƒœï¼Œæä½åˆ†æ•°
            }
            const score = minimax(depth - 1, true, alpha, beta, move.r, move.c);
            board[move.r][move.c] = 0;
            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break; // Alpha-Betaå‰ªæ
        }
        return minScore;
    }
}

// è¯„ä¼°æ•´ä¸ªæ£‹ç›˜çŠ¶æ€
function evaluateBoard() {
    let aiScore = 0, playerScore = 0;
    
    // è¯„ä¼°æ‰€æœ‰ç©ºä½
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) {
                aiScore += evaluate(r, c, 2) * 0.8;
                playerScore += evaluate(r, c, 1);
            }
        }
    }
    
    return aiScore - playerScore;
}

// æ’åºçš„å€™é€‰ç§»åŠ¨ - ä¼˜å…ˆè¯„ä¼°æ›´æœ‰ä»·å€¼çš„ä½ç½®
function getSortedCandidateMoves() {
    const moves = [];
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) {
                // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰æ£‹å­
                let hasNeighbor = false;
                for (let dr = -2; dr <= 2; dr++) {
                    for (let dc = -2; dc <= 2; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                            hasNeighbor = true;
                            break;
                        }
                    }
                    if (hasNeighbor) break;
                }
                if (hasNeighbor) {
                    // è¯„ä¼°è¿™ä¸ªä½ç½®çš„åˆ†æ•°
                    const score = evaluate(r, c, 2) + evaluate(r, c, 1) * 0.9;
                    moves.push({ r, c, score });
                }
            }
        }
    }
    
    // æŒ‰åˆ†æ•°æ’åº
    moves.sort((a, b) => b.score - a.score);
    
    if (moves.length === 0) {
        return [{ r: 7, c: 7, score: 0 }];
    }
    
    return moves.map(m => ({ r: m.r, c: m.c }));
}

// æŠ€èƒ½
async function useSkill(id) {
    if (gameOver || currentPlayer !== 1 || skillsUsed[id]) return;
    
    initAudio();
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    playSkillSound();
    
    switch(id) {
        case 1:
            extraMove = true;
            skillsUsed[1] = true;
            updateSkillButtons();
            break;
        case 2:
            removeMode = true;
            skillsUsed[2] = true;
            updateSkillButtons();
            alert('ç‚¹å‡»ç™½å­å°†å…¶ç§»é™¤');
            break;
        case 3:
            if (moveHistory.length < 3) { alert('æ­¥æ•°ä¸è¶³'); return; }
            for (let i = 0; i < 3; i++) {
                const last = moveHistory.pop();
                if (last) board[last.r][last.c] = 0;
            }
            currentPlayer = 1;
            skillsUsed[3] = true;
            updateSkillButtons();
            drawBoard();
            updateTurnIndicator();
            break;
    }
}

function updateSkillButtons() {
    for (let i = 1; i <= 3; i++) {
        document.getElementById('skill' + i).disabled = skillsUsed[i];
    }
}

function setDifficulty(level) {
    difficulty = level;
    document.querySelectorAll('.diff-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.includes(
            level === 'easy' ? 'å…¥é—¨' :
            level === 'medium' ? 'æ™®é€š' :
            level === 'hard' ? 'å›°éš¾' : 'å¤§å¸ˆ'
        ));
    });
    restartGame();
}

function restartGame() {
    initBoard();
}

function undoMove() {
    if (moveHistory.length < 2 || gameOver) return;
    for (let i = 0; i < 2; i++) {
        const last = moveHistory.pop();
        if (last) board[last.r][last.c] = 0;
    }
    currentPlayer = 1;
    drawBoard();
    updateTurnIndicator();
}

function showHint() {
    if (gameOver || currentPlayer !== 1) return;
    let best = null, bestScore = -Infinity;
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            if (board[r][c] === 0) {
                const score = evaluate(r, c, 1);
                if (score > bestScore) { bestScore = score; best = { r, c }; }
            }
    if (best) {
        const x = MARGIN + best.c * CELL_SIZE;
        const y = MARGIN + best.r * CELL_SIZE;
        ctx.strokeStyle = '#c41e3a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, CELL_SIZE * 0.4, 0, Math.PI * 2);
        ctx.stroke();
        setTimeout(drawBoard, 1500);
    }
}

function updateTurnIndicator() {
    const el = document.getElementById('turnIndicator');
    if (currentPlayer === 1) {
        el.innerHTML = 'âš« é»‘æ–¹è½å­';
        el.style.background = 'linear-gradient(135deg, #2a2a2a, #1a1a1a)';
    } else {
        el.innerHTML = 'âšª ç™½æ–¹æ€è€ƒä¸­...';
        el.style.background = 'linear-gradient(135deg, #5a5a5a, #3a3a3a)';
    }
}

function updateScore() {
    document.getElementById('blackScore').textContent = blackScore;
    document.getElementById('whiteScore').textContent = whiteScore;
}

// ç¥ç¦è¯­åº“
const blessings = [
    'æ–°å¹´å¿«ä¹ï¼Œä¸‡äº‹å¦‚æ„ï¼',
    'æ£‹å¼€å¾—èƒœï¼Œæ­¥æ­¥é«˜å‡ï¼',
    'äº”å­è¿ç ï¼Œäº”ç¦ä¸´é—¨ï¼',
    'æ£‹è‰ºç²¾è¿›ï¼Œé¾™å¹´å¤§å‰ï¼',
    'è¿ç­¹å¸·å¹„ï¼Œå†³èƒœåƒé‡Œï¼',
    'æ™ºç åœ¨æ¡ï¼Œä¸‡äº‹äº¨é€šï¼'
];

// åˆ›å»ºçƒŸèŠ±æ•ˆæœ
function createFireworks() {
    const colors = ['#ff0000', '#ffd700', '#ff69b4', '#00ff00', '#00bfff', '#ff8c00'];
    for (let i = 0; i < 50; i++) {
        const firework = document.createElement('div');
        firework.className = 'firework';
        firework.style.left = Math.random() * window.innerWidth + 'px';
        firework.style.top = Math.random() * window.innerHeight + 'px';
        firework.style.background = colors[Math.floor(Math.random() * colors.length)];
        firework.style.setProperty('--tx', (Math.random() - 0.5) * 200 + 'px');
        firework.style.setProperty('--ty', (Math.random() - 0.5) * 200 + 'px');
        document.body.appendChild(firework);
        setTimeout(() => firework.remove(), 1000);
    }
}

// åˆ›å»ºé£˜è½è£…é¥°
function createPetals() {
    const decorations = ['ğŸ§§', 'ğŸ®', 'ğŸŠ', 'âœ¨', 'ğŸ‹'];
    for (let i = 0; i < 15; i++) {
        const petal = document.createElement('div');
        petal.className = 'petal';
        petal.textContent = decorations[Math.floor(Math.random() * decorations.length)];
        petal.style.left = Math.random() * window.innerWidth + 'px';
        petal.style.animationDuration = (Math.random() * 5 + 5) + 's';
        petal.style.animationDelay = Math.random() * 5 + 's';
        document.body.appendChild(petal);
        setTimeout(() => petal.remove(), 10000);
    }
}

async function showModal(type, message) {
    // ç¡®ä¿éŸ³é¢‘å·²åˆå§‹åŒ–å¹¶æ¢å¤
    initAudio();
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    
    const modal = document.getElementById('modal');
    const title = document.getElementById('modalTitle');
    const desc = document.getElementById('modalDesc');
    const blessing = document.getElementById('modalBlessing');
    
    title.textContent = message;
    title.className = type;
    modal.style.display = 'flex';
    
    if (type === 'win') {
        desc.innerHTML = 'ğŸŠ äº”å­è¿ç ï¼Œå¦™æ‰‹å¤©æˆï¼ğŸŠ';
        blessing.textContent = blessings[Math.floor(Math.random() * blessings.length)];
        // æ’­æ”¾èƒœåˆ©éŸ³æ•ˆ
        playWinSound();
        // æ”¾çƒŸèŠ±
        createFireworks();
        // æŒç»­æ”¾çƒŸèŠ±
        const fireworkInterval = setInterval(createFireworks, 1500);
        modal.dataset.fireworkInterval = fireworkInterval;
    } else if (type === 'lose') {
        desc.textContent = 'æ£‹å·®ä¸€ç€ï¼Œå†æ¥å†å‰ï¼';
        blessing.textContent = 'èƒœè´¥ä¹ƒå…µå®¶å¸¸äº‹ï¼Œé‡æ•´æ——é¼“å†å‡ºå‘ï¼';
        playLoseSound();
    } else {
        desc.textContent = 'å¹³åˆ†ç§‹è‰²ï¼Œä¸åˆ†ä¼¯ä»²ï¼';
        blessing.textContent = 'å’Œä¸ºè´µï¼Œæ£‹é€¢å¯¹æ‰‹äº¦æ˜¯ä¹äº‹ï¼';
    }
}

function closeModal() {
    const modal = document.getElementById('modal');
    modal.style.display = 'none';
    // æ¸…é™¤çƒŸèŠ±å®šæ—¶å™¨
    if (modal.dataset.fireworkInterval) {
        clearInterval(parseInt(modal.dataset.fireworkInterval));
        delete modal.dataset.fireworkInterval;
    }
    restartGame();
}

initBoard();
initAudio();
</script>
</body>
</html>