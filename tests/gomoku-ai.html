<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ€èƒ½äº”å­æ£‹ - AIå¯¹æˆ˜ç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        h1 {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #0ff;
            background: linear-gradient(90deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        #gameContainer {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }
        
        #boardSection {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #board {
            background: #dcb35c;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            position: relative;
        }
        
        #canvas {
            display: block;
            cursor: pointer;
        }
        
        #sidebar {
            width: 280px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .panel {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 3px solid;
        }
        
        .panel.player { border-color: #0ff; }
        .panel.ai { border-color: #f55; }
        
        .panel h3 {
            font-size: 16px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .skill-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .skill-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        
        .skill-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .skill-cooldown {
            font-size: 12px;
            opacity: 0.8;
        }
        
        .skill-1 { background: linear-gradient(135deg, #4a9, #2a7); color: #fff; }
        .skill-2 { background: linear-gradient(135deg, #a49, #727); color: #fff; }
        .skill-3 { background: linear-gradient(135deg, #49a, #247); color: #fff; }
        
        #status {
            text-align: center;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        #status .turn {
            font-size: 20px;
            font-weight: bold;
        }
        
        #status .turn.player { color: #0ff; }
        #status .turn.ai { color: #f55; }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #0af, #08f);
            color: #fff;
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        
        #difficulty {
            margin-bottom: 15px;
        }
        
        #difficulty select {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 14px;
        }
        
        #winnerModal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #winnerModal .content {
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #1a1a3e, #2a2a5e);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        
        #winnerModal h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .win-player { color: #0ff; text-shadow: 0 0 20px #0ff; }
        .win-ai { color: #f55; text-shadow: 0 0 20px #f55; }
        
        .score-board {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        
        .score-item {
            text-align: center;
        }
        
        .score-value {
            font-size: 28px;
            font-weight: bold;
        }
        
        .score-label {
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <h1>ğŸ”® æŠ€èƒ½äº”å­æ£‹</h1>
    
    <div id="gameContainer">
        <div id="boardSection">
            <div id="board">
                <canvas id="canvas" width="600" height="600"></canvas>
            </div>
            
            <div class="controls">
                <button class="btn btn-primary" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
                <button class="btn btn-secondary" onclick="undoMove()">â†©ï¸ æ‚”æ£‹</button>
                <button class="btn btn-secondary" onclick="showHint()">ğŸ’¡ æç¤º</button>
            </div>
        </div>
        
        <div id="sidebar">
            <div id="status">
                <div id="turnDisplay" class="turn player">âš« ä½ çš„å›åˆ</div>
            </div>
            
            <div class="score-board">
                <div class="score-item">
                    <div class="score-value" id="playerScore">0</div>
                    <div class="score-label">ä½  (âš«)</div>
                </div>
                <div class="score-item">
                    <div class="score-value" id="aiScore">0</div>
                    <div class="score-label">AI (âšª)</div>
                </div>
            </div>
            
            <div id="difficulty">
                <select id="difficultySelect" onchange="setDifficulty(this.value)">
                    <option value="easy">ğŸŸ¢ ç®€å•</option>
                    <option value="medium" selected>ğŸŸ¡ ä¸­ç­‰</option>
                    <option value="hard">ğŸ”´ å›°éš¾</option>
                    <option value="expert">ğŸ’€ ä¸“å®¶</option>
                </select>
            </div>
            
            <div class="panel player">
                <h3>âš« ä½ çš„æŠ€èƒ½</h3>
                <button class="skill-btn skill-1" id="skill1" onclick="useSkill(1)">
                    <span>ğŸ¯ åŒé‡æ‰“å‡»</span>
                    <span class="skill-cooldown">è¿ç»­ä¸‹ä¸¤å­</span>
                </button>
                <button class="skill-btn skill-2" id="skill2" onclick="useSkill(2)">
                    <span>ğŸ›¡ï¸ é˜²å®ˆåå‡»</span>
                    <span class="skill-cooldown">ç§»é™¤å¯¹æ–¹ä¸€å­</span>
                </button>
                <button class="skill-btn skill-3" id="skill3" onclick="useSkill(3)">
                    <span>âš¡ æ—¶ç©ºå›æº¯</span>
                    <span class="skill-cooldown">å›é€€3æ­¥</span>
                </button>
            </div>
            
            <div class="panel ai">
                <h3>âšª AIæŠ€èƒ½</h3>
                <p style="font-size: 13px; color: #aaa; line-height: 1.6;">
                    AIæ ¹æ®éš¾åº¦ä½¿ç”¨ä¸åŒç­–ç•¥ï¼š<br><br>
                    ğŸŸ¢ ç®€å•ï¼šéšæœºè½å­<br>
                    ğŸŸ¡ ä¸­ç­‰ï¼šåŸºç¡€è¯„åˆ†<br>
                    ğŸ”´ å›°éš¾ï¼šMinimaxç®—æ³•<br>
                    ğŸ’€ ä¸“å®¶ï¼šAlpha-Betaå‰ªæ
                </p>
            </div>
        </div>
    </div>
    
    <div id="winnerModal">
        <div class="content">
            <h2 id="winnerText"></h2>
            <p id="winReason" style="margin-bottom: 20px; color: #aaa;"></p>
            <button class="btn btn-primary" onclick="closeModal()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// æ¸¸æˆé…ç½®
const BOARD_SIZE = 15;
const CELL_SIZE = 38;
const MARGIN = 22;

// æ¸¸æˆçŠ¶æ€
let board = [];
let currentPlayer = 1; // 1=ç©å®¶(é»‘), 2=AI(ç™½)
let gameOver = false;
let difficulty = 'medium';
let moveHistory = [];
let playerScore = 0;
let aiScore = 0;

// æŠ€èƒ½å†·å´
let skills = {
    1: { used: false, cooldown: 0 },
    2: { used: false, cooldown: 0 },
    3: { used: false, cooldown: 0 }
};

// åˆå§‹åŒ–æ£‹ç›˜
function initBoard() {
    board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0));
    currentPlayer = 1;
    gameOver = false;
    moveHistory = [];
    skills = { 1: { used: false, cooldown: 0 }, 2: { used: false, cooldown: 0 }, 3: { used: false, cooldown: 0 } };
    updateSkillButtons();
    drawBoard();
    updateStatus();
}

// ç»˜åˆ¶æ£‹ç›˜
function drawBoard() {
    // èƒŒæ™¯
    ctx.fillStyle = '#dcb35c';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç½‘æ ¼çº¿
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        // æ¨ªçº¿
        ctx.beginPath();
        ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
        ctx.lineTo(MARGIN + (BOARD_SIZE - 1) * CELL_SIZE, MARGIN + i * CELL_SIZE);
        ctx.stroke();
        
        // ç«–çº¿
        ctx.beginPath();
        ctx.moveTo(MARGIN + i * CELL_SIZE, MARGIN);
        ctx.lineTo(MARGIN + i * CELL_SIZE, MARGIN + (BOARD_SIZE - 1) * CELL_SIZE);
        ctx.stroke();
    }
    
    // æ˜Ÿä½
    const stars = [[3,3], [3,7], [3,11], [7,3], [7,7], [7,11], [11,3], [11,7], [11,11]];
    ctx.fillStyle = '#000';
    stars.forEach(([r, c]) => {
        ctx.beginPath();
        ctx.arc(MARGIN + c * CELL_SIZE, MARGIN + r * CELL_SIZE, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // ç»˜åˆ¶æ£‹å­
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] !== 0) {
                drawPiece(r, c, board[r][c]);
            }
        }
    }
    
    // ç»˜åˆ¶æœ€åè½å­æ ‡è®°
    if (moveHistory.length > 0) {
        const last = moveHistory[moveHistory.length - 1];
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(MARGIN + last.c * CELL_SIZE, MARGIN + last.r * CELL_SIZE, 6, 0, Math.PI * 2);
        ctx.stroke();
    }
}

// ç»˜åˆ¶æ£‹å­
function drawPiece(r, c, player) {
    const x = MARGIN + c * CELL_SIZE;
    const y = MARGIN + r * CELL_SIZE;
    const radius = CELL_SIZE * 0.4;
    
    // é˜´å½±
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    // æ£‹å­ä¸»ä½“
    const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, 0, x, y, radius);
    if (player === 1) {
        gradient.addColorStop(0, '#666');
        gradient.addColorStop(1, '#000');
    } else {
        gradient.addColorStop(0, '#fff');
        gradient.addColorStop(1, '#ccc');
    }
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
}

// ç‚¹å‡»ä¸‹æ£‹
canvas.addEventListener('click', (e) => {
    if (gameOver || currentPlayer !== 1) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const c = Math.round((x - MARGIN) / CELL_SIZE);
    const r = Math.round((y - MARGIN) / CELL_SIZE);
    
    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === 0) {
        makeMove(r, c, 1);
    }
});

// è½å­
function makeMove(r, c, player) {
    board[r][c] = player;
    moveHistory.push({ r, c, player });
    drawBoard();
    
    if (checkWin(r, c, player)) {
        gameOver = true;
        const winner = player === 1 ? 'ä½ èµ¢äº†ï¼' : 'AIè·èƒœï¼';
        const className = player === 1 ? 'win-player' : 'win-ai';
        showWinner(winner, className, player === 1 ? 'äº”å­è¿ç ï¼' : 'AIè¾¾æˆäº”è¿ï¼');
        if (player === 1) playerScore++;
        else aiScore++;
        updateScore();
        return;
    }
    
    if (checkDraw()) {
        gameOver = true;
        showWinner('å¹³å±€ï¼', '', 'æ£‹ç›˜å·²æ»¡');
        return;
    }
    
    currentPlayer = 3 - player;
    updateStatus();
    
    if (currentPlayer === 2) {
        setTimeout(aiMove, 300);
    }
}

// æ£€æŸ¥èƒœè´Ÿ
function checkWin(r, c, player) {
    const directions = [[0,1], [1,0], [1,1], [1,-1]];
    
    for (let [dr, dc] of directions) {
        let count = 1;
        
        // æ­£å‘
        for (let i = 1; i < 5; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                count++;
            } else break;
        }
        
        // åå‘
        for (let i = 1; i < 5; i++) {
            const nr = r - dr * i, nc = c - dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                count++;
            } else break;
        }
        
        if (count >= 5) return true;
    }
    return false;
}

// æ£€æŸ¥å¹³å±€
function checkDraw() {
    return board.every(row => row.every(cell => cell !== 0));
}

// AIä¸‹æ£‹
function aiMove() {
    if (gameOver) return;
    
    let move;
    switch(difficulty) {
        case 'easy':
            move = getRandomMove();
            break;
        case 'medium':
            move = getGreedyMove();
            break;
        case 'hard':
            move = getMinimaxMove(2);
            break;
        case 'expert':
            move = getMinimaxMove(4);
            break;
    }
    
    if (move) {
        makeMove(move.r, move.c, 2);
    }
}

// éšæœºè½å­
function getRandomMove() {
    const empty = [];
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) empty.push({ r, c });
        }
    }
    return empty[Math.floor(Math.random() * empty.length)];
}

// è´ªå¿ƒç­–ç•¥
function getGreedyMove() {
    let bestScore = -Infinity;
    let bestMove = null;
    
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) {
                const score = evaluatePosition(r, c, 2) + evaluatePosition(r, c, 1) * 0.8;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { r, c };
                }
            }
        }
    }
    return bestMove;
}

// è¯„ä¼°å‡½æ•°
function evaluatePosition(r, c, player) {
    let score = 0;
    const directions = [[0,1], [1,0], [1,1], [1,-1]];
    
    for (let [dr, dc] of directions) {
        let count = 1;
        let blocked = 0;
        
        for (let i = 1; i < 5; i++) {
            const nr = r + dr * i, nc = c + dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (board[nr][nc] === player) count++;
                else if (board[nr][nc] !== 0) { blocked++; break; }
                else break;
            } else { blocked++; break; }
        }
        
        for (let i = 1; i < 5; i++) {
            const nr = r - dr * i, nc = c - dc * i;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                if (board[nr][nc] === player) count++;
                else if (board[nr][nc] !== 0) { blocked++; break; }
                else break;
            } else { blocked++; break; }
        }
        
        if (count >= 5) score += 100000;
        else if (count === 4 && blocked === 0) score += 10000;
        else if (count === 4 && blocked === 1) score += 1000;
        else if (count === 3 && blocked === 0) score += 1000;
        else if (count === 3 && blocked === 1) score += 100;
        else if (count === 2 && blocked === 0) score += 100;
        else score += count * 10;
    }
    
    return score;
}

// Minimaxç®—æ³•
function getMinimaxMove(depth) {
    let bestScore = -Infinity;
    let bestMove = null;
    
    const moves = getCandidateMoves();
    
    for (let move of moves) {
        board[move.r][move.c] = 2;
        const score = minimax(depth - 1, false, -Infinity, Infinity);
        board[move.r][move.c] = 0;
        
        if (score > bestScore) {
            bestScore = score;
            bestMove = move;
        }
    }
    
    return bestMove || getGreedyMove();
}

function minimax(depth, isMaximizing, alpha, beta) {
    if (depth === 0) return evaluateBoard();
    
    const moves = getCandidateMoves();
    if (moves.length === 0) return 0;
    
    if (isMaximizing) {
        let maxScore = -Infinity;
        for (let move of moves) {
            board[move.r][move.c] = 2;
            if (checkWin(move.r, move.c, 2)) {
                board[move.r][move.c] = 0;
                return 1000000;
            }
            const score = minimax(depth - 1, false, alpha, beta);
            board[move.r][move.c] = 0;
            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break;
        }
        return maxScore;
    } else {
        let minScore = Infinity;
        for (let move of moves) {
            board[move.r][move.c] = 1;
            if (checkWin(move.r, move.c, 1)) {
                board[move.r][move.c] = 0;
                return -1000000;
            }
            const score = minimax(depth - 1, true, alpha, beta);
            board[move.r][move.c] = 0;
            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break;
        }
        return minScore;
    }
}

function getCandidateMoves() {
    const moves = [];
    const hasNeighbor = (r, c) => {
        for (let dr = -2; dr <= 2; dr++) {
            for (let dc = -2; dc <= 2; dc++) {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                    return true;
                }
            }
        }
        return false;
    };
    
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0 && hasNeighbor(r, c)) {
                moves.push({ r, c });
            }
        }
    }
    
    if (moves.length === 0) {
        return [{ r: 7, c: 7 }];
    }
    
    return moves.sort((a, b) => {
        return evaluatePosition(b.r, b.c, 2) + evaluatePosition(b.r, b.c, 1) -
               evaluatePosition(a.r, a.c, 2) - evaluatePosition(a.r, a.c, 1);
    }).slice(0, 10);
}

function evaluateBoard() {
    let score = 0;
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 2) score += evaluatePosition(r, c, 2);
            else if (board[r][c] === 1) score -= evaluatePosition(r, c, 1);
        }
    }
    return score;
}

// æŠ€èƒ½ç³»ç»Ÿ
function useSkill(skillId) {
    if (gameOver || currentPlayer !== 1 || skills[skillId].used) return;
    
    switch(skillId) {
        case 1: // åŒé‡æ‰“å‡»
            if (moveHistory.length >= 2) {
                alert('æ£‹å±€ä¸­åæœŸæ‰èƒ½ä½¿ç”¨ï¼');
                return;
            }
            skills[1].used = true;
            updateSkillButtons();
            // ä¸‹ä¸¤å­çš„æ•ˆæœåœ¨makeMoveä¸­å¤„ç†
            break;
            
        case 2: // é˜²å®ˆåå‡»
            let removed = false;
            for (let r = 0; r < BOARD_SIZE && !removed; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 2) {
                        board[r][c] = 0;
                        removed = true;
                        skills[2].used = true;
                        updateSkillButtons();
                        drawBoard();
                        break;
                    }
                }
            }
            break;
            
        case 3: // æ—¶ç©ºå›æº¯
            if (moveHistory.length < 3) {
                alert('éœ€è¦è‡³å°‘3æ­¥æ‰èƒ½å›æº¯ï¼');
                return;
            }
            for (let i = 0; i < 3; i++) {
                const last = moveHistory.pop();
                if (last) board[last.r][last.c] = 0;
            }
            currentPlayer = 1;
            skills[3].used = true;
            updateSkillButtons();
            drawBoard();
            updateStatus();
            break;
    }
}

function updateSkillButtons() {
    for (let i = 1; i <= 3; i++) {
        const btn = document.getElementById('skill' + i);
        if (skills[i].used) {
            btn.disabled = true;
            btn.querySelector('.skill-cooldown').textContent = 'å·²ä½¿ç”¨';
        }
    }
}

// å…¶ä»–åŠŸèƒ½
function setDifficulty(level) {
    difficulty = level;
    restartGame();
}

function restartGame() {
    initBoard();
}

function undoMove() {
    if (moveHistory.length < 2 || gameOver) return;
    // å›é€€ä¸¤æ­¥ï¼ˆç©å®¶å’ŒAIå„ä¸€æ­¥ï¼‰
    for (let i = 0; i < 2; i++) {
        const last = moveHistory.pop();
        if (last) board[last.r][last.c] = 0;
    }
    currentPlayer = 1;
    drawBoard();
    updateStatus();
}

function showHint() {
    if (gameOver || currentPlayer !== 1) return;
    let bestScore = -Infinity;
    let bestMove = null;
    
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) {
                const score = evaluatePosition(r, c, 1);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { r, c };
                }
            }
        }
    }
    
    if (bestMove) {
        // é«˜äº®æç¤ºä½ç½®
        const x = MARGIN + bestMove.c * CELL_SIZE;
        const y = MARGIN + bestMove.r * CELL_SIZE;
        
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, CELL_SIZE * 0.4, 0, Math.PI * 2);
        ctx.stroke();
        
        setTimeout(drawBoard, 1000);
    }
}

function updateStatus() {
    const display = document.getElementById('turnDisplay');
    if (currentPlayer === 1) {
        display.textContent = 'âš« ä½ çš„å›åˆ';
        display.className = 'turn player';
    } else {
        display.textContent = 'âšª AIæ€è€ƒä¸­...';
        display.className = 'turn ai';
    }
}

function updateScore() {
    document.getElementById('playerScore').textContent = playerScore;
    document.getElementById('aiScore').textContent = aiScore;
}

function showWinner(text, className, reason) {
    const modal = document.getElementById('winnerModal');
    const winnerText = document.getElementById('winnerText');
    const winReason = document.getElementById('winReason');
    
    winnerText.textContent = text;
    winnerText.className = className;
    winReason.textContent = reason;
    modal.style.display = 'flex';
}

function closeModal() {
    document.getElementById('winnerModal').style.display = 'none';
    restartGame();
}

// å¯åŠ¨æ¸¸æˆ
initBoard();
</script>
</body>
</html>