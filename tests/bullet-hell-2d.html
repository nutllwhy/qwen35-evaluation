<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§§ æ–°æ˜¥å¼¹å¹•å¤§ä½œæˆ˜ ğŸ§§</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a0a0a 0%, #2d1810 50%, #1a0a0a 100%);
            color: #fff;
            font-family: 'Microsoft YaHei', sans-serif;
            user-select: none;
        }
        
        /* èƒŒæ™¯è£…é¥° */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(255, 0, 0, 0.1) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }
        
        canvas {
            display: block;
            position: relative;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud {
            position: absolute;
            padding: 12px 24px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.8), rgba(196, 30, 58, 0.8));
            border: 2px solid #ffd700;
            border-radius: 12px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
        }
        
        #score { 
            top: 20px; 
            left: 20px; 
            color: #ffd700; 
            font-size: 22px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        #wave { 
            top: 20px; 
            right: 20px; 
            color: #ff6b6b; 
            font-size: 20px;
        }
        
        #level {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0f0;
            font-size: 20px;
        }
        
        #next-level {
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        #next-level .progress-bar {
            width: 150px;
            height: 8px;
            background: #333;
            border: 1px solid #ffd700;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #next-level .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff8c00);
            transition: width 0.3s;
        }
        
        #health {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #health-bar {
            width: 220px;
            height: 14px;
            background: #333;
            border: 2px solid #ffd700;
            border-radius: 7px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #c41e3a, #ffd700);
            transition: width 0.2s;
        }
        
        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 150px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.8), rgba(196, 30, 58, 0.8));
            border: 2px solid #ffd700;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            z-index: 100;
            pointer-events: auto;
        }
        
        #game-over {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(139, 0, 0, 0.9);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }
        
        #game-over h1 {
            font-size: 72px;
            color: #ffd700;
            text-shadow: 
                0 0 20px #ffd700,
                0 0 40px #ff0000;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #game-over .blessing {
            font-size: 24px;
            color: #fff;
            margin-bottom: 30px;
            padding: 15px 30px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 25px;
            border: 2px solid #ffd700;
        }
        
        #game-over button {
            padding: 18px 50px;
            font-size: 24px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: 3px solid #fff;
            border-radius: 30px;
            color: #8b0000;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            transition: all 0.3s;
        }
        
        #game-over button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }
        
        #instructions {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 14px;
            text-align: center;
            background: rgba(139, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid #ffd700;
        }
        
        /* é£˜è½è£…é¥° */
        .lantern {
            position: fixed;
            font-size: 30px;
            animation: float linear infinite;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes float {
            to {
                transform: translateY(100vh) rotate(10deg);
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="hud" id="score">ğŸ§§ _score: 0</div>
        <div class="hud" id="wave">ğŸŒŠ æ³¢æ¬¡: 1</div>
        <div class="hud" id="level">â­ ç­‰çº§: 1</div>
        <div class="hud" id="next-level">
            <span>ğŸ“ˆ ä¸‹ä¸€çº§</span>
            <div class="progress-bar">
                <div class="progress-fill" id="level-progress"></div>
            </div>
        </div>
        <button id="audio-toggle" onclick="toggleAudio()">ğŸ”Š</button>
        <div class="hud" id="health">
            <span>â¤ï¸ ç”Ÿå‘½å€¼</span>
            <div id="health-bar"><div id="health-fill"></div></div>
        </div>
        <div id="instructions">
            ğŸ–±ï¸ é¼ æ ‡ç§»åŠ¨ | è‡ªåŠ¨å°„å‡» | èº²é¿çº¢è‰²å¼¹å¹• ğŸ®
        </div>
    </div>
    
    <div id="game-over">
        <h1>ğŸŠ æ–°æ˜¥å¿«ä¹ ğŸŠ</h1>
        <div class="blessing" id="blessing">æ¸¸æˆç»“æŸ</div>
        <button onclick="game.restart()">ğŸ® å†æ¥ä¸€å±€</button>
    </div>

<script>
// ==================== éŸ³é¢‘ç³»ç»Ÿ ====================
let audioEnabled = true;
let audioContext = null;
let bgmOscillators = [];
let isBgmPlaying = false;

// åˆå§‹åŒ–éŸ³é¢‘
async function initAudio() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    if (!isBgmPlaying && audioEnabled) {
        startBGM();
    }
}

async function toggleAudio() {
    audioEnabled = !audioEnabled;
    document.getElementById('audio-toggle').textContent = audioEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
    if (audioEnabled) {
        await initAudio();
    } else {
        stopBGM();
    }
}

// å–œåº†èƒŒæ™¯éŸ³ä¹ - ç”µå­å›½é£
const bgmPattern = [
    { note: 523.25, duration: 0.2 }, { note: 587.33, duration: 0.2 },
    { note: 659.25, duration: 0.2 }, { note: 783.99, duration: 0.3 },
    { note: 659.25, duration: 0.2 }, { note: 587.33, duration: 0.2 },
    { note: 523.25, duration: 0.4 }, { note: 0, duration: 0.1 },
    { note: 659.25, duration: 0.2 }, { note: 698.46, duration: 0.2 },
    { note: 783.99, duration: 0.2 }, { note: 880.00, duration: 0.3 },
    { note: 783.99, duration: 0.2 }, { note: 698.46, duration: 0.2 },
    { note: 659.25, duration: 0.4 }
];

let bgmIndex = 0;
let nextNoteTime = 0;
let bgmTimer = null;

function startBGM() {
    if (!audioEnabled || !audioContext || isBgmPlaying) return;
    isBgmPlaying = true;
    bgmIndex = 0;
    nextNoteTime = audioContext.currentTime;
    scheduleBGMNotes();
}

function scheduleBGMNotes() {
    if (!isBgmPlaying || !audioEnabled) return;
    
    const currentTime = audioContext.currentTime;
    
    while (nextNoteTime < currentTime + 0.5) {
        const noteData = bgmPattern[bgmIndex];
        
        if (noteData.note > 0) {
            // ä¸»éŸ³
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = noteData.note;
            osc.type = 'square';
            
            // ä½é€šæ»¤æ³¢å™¨æŸ”åŒ–éŸ³è‰²
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1500;
            
            osc.disconnect();
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            gain.gain.setValueAtTime(0.08, nextNoteTime);
            gain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + noteData.duration * 0.8);
            
            osc.start(nextNoteTime);
            osc.stop(nextNoteTime + noteData.duration);
            
            // ä½éŸ³ä¼´å¥
            const bassOsc = audioContext.createOscillator();
            const bassGain = audioContext.createGain();
            bassOsc.connect(bassGain);
            bassGain.connect(audioContext.destination);
            
            bassOsc.frequency.value = noteData.note / 4;
            bassOsc.type = 'sine';
            bassGain.gain.value = 0.05;
            
            bassOsc.start(nextNoteTime);
            bassOsc.stop(nextNoteTime + noteData.duration);
        }
        
        nextNoteTime += noteData.duration;
        bgmIndex = (bgmIndex + 1) % bgmPattern.length;
    }
    
    bgmTimer = setTimeout(scheduleBGMNotes, 100);
}

function stopBGM() {
    isBgmPlaying = false;
    if (bgmTimer) {
        clearTimeout(bgmTimer);
        bgmTimer = null;
    }
}

// éŸ³æ•ˆå‡½æ•°
function playShootSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.frequency.setValueAtTime(1200, t);
    osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
    osc.type = 'square';
    
    gain.gain.setValueAtTime(0.15, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
    
    osc.start(t);
    osc.stop(t + 0.1);
}

function playExplosionSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    
    // å™ªå£°çˆ†å‘
    const bufferSize = audioContext.sampleRate * 0.2;
    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
    }
    
    const noise = audioContext.createBufferSource();
    noise.buffer = buffer;
    const noiseGain = audioContext.createGain();
    noiseGain.gain.setValueAtTime(0.2, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    
    // ä½é¢‘éœ‡è¡
    const osc = audioContext.createOscillator();
    const oscGain = audioContext.createGain();
    osc.frequency.setValueAtTime(100, t);
    osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
    oscGain.gain.setValueAtTime(0.15, t);
    oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
    
    noise.connect(noiseGain);
    noiseGain.connect(audioContext.destination);
    osc.connect(oscGain);
    oscGain.connect(audioContext.destination);
    
    noise.start(t);
    osc.start(t);
    noise.stop(t + 0.2);
    osc.stop(t + 0.2);
}

function playHitSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
    osc.type = 'sawtooth';
    
    gain.gain.setValueAtTime(0.2, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
    
    osc.start(t);
    osc.stop(t + 0.15);
}

function playLevelUpSound() {
    if (!audioEnabled || !audioContext) return;
    const t = audioContext.currentTime;
    const notes = [523.25, 659.25, 783.99, 1046.50];
    
    notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.frequency.value = freq;
        osc.type = 'sine';
        
        const startTime = t + i * 0.08;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.2, startTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);
        
        osc.start(startTime);
        osc.stop(startTime + 0.5);
    });
}

// ==================== æ¸¸æˆä»£ç  ====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const blessings = [
    'æ–°å¹´å¿«ä¹ï¼Œä¸‡äº‹å¦‚æ„ï¼',
    'å¼¹å¹•è¿æ˜¥ï¼Œæ­¥æ­¥é«˜å‡ï¼',
    'é¿å¼¹å¦‚ç¥ï¼Œäº”ç¦ä¸´é—¨ï¼',
    'é¾™å¹´å¤§å‰ï¼Œæˆ˜æ— ä¸èƒœï¼',
    'çº¢çº¢ç«ç«ï¼Œå¥½è¿è¿è¿ï¼'
];

// åˆ›å»ºé£˜è½çš„ç¯ç¬¼
function createLanterns() {
    const decorations = ['ğŸ®', 'ğŸ§§', 'ğŸŠ', 'âœ¨'];
    for (let i = 0; i < 8; i++) {
        const lantern = document.createElement('div');
        lantern.className = 'lantern';
        lantern.textContent = decorations[Math.floor(Math.random() * decorations.length)];
        lantern.style.left = Math.random() * window.innerWidth + 'px';
        lantern.style.animationDuration = (Math.random() * 8 + 8) + 's';
        lantern.style.animationDelay = Math.random() * 5 + 's';
        document.body.appendChild(lantern);
        setTimeout(() => lantern.remove(), 16000);
    }
}

// æ¸¸æˆé…ç½® - åŠ¨æ€éš¾åº¦ç³»ç»Ÿ
const CONFIG = {
    playerSpeed: 0.12,
    playerHealth: 100,
    colors: {
        player: '#ffd700',
        playerBullet: '#ff6b6b',
        enemy: '#ff4757',
        enemyBullet: '#ff3838'
    }
};

// åŠ¨æ€è·å–å½“å‰ç­‰çº§ä¸‹çš„æ¸¸æˆå‚æ•°
function getGameParams(level) {
    // ç­‰çº§1-20çš„æ¸è¿›å¼éš¾åº¦æ›²çº¿
    const progress = Math.min(level, 20) / 20;
    
    return {
        // å°„é€Ÿï¼šä»æ…¢(12å¸§)åˆ°å¿«(3å¸§)
        fireRate: Math.max(3, Math.floor(12 - progress * 9)),
        
        // å­å¼¹æ•°é‡ï¼šä»1å‘åˆ°5å‘æ•£å°„
        bulletCount: Math.min(5, 1 + Math.floor(progress * 4)),
        
        // å­å¼¹é€Ÿåº¦ï¼šä»æ…¢åˆ°å¿«
        bulletSpeed: 8 + progress * 8,
        
        // æ•Œäººç”Ÿæˆé—´éš”ï¼šä»ç¨€ç–(100å¸§)åˆ°å¯†é›†(15å¸§)
        spawnRate: Math.max(15, Math.floor(100 - progress * 85)),
        
        // æ•Œäººé€Ÿåº¦åŠ æˆ
        enemySpeedBonus: 1 + progress * 2,
        
        // æ•Œäººè¡€é‡åŠ æˆ
        enemyHpBonus: 1 + progress * 2,
        
        // æ•Œå¼¹é€Ÿåº¦
        enemyBulletSpeed: 4 + progress * 6,
        
        // æœ€å¤§åŒå±æ•Œäººæ•°é‡
        maxEnemies: Math.min(30, 3 + Math.floor(progress * 27))
    };
}

// æ¸¸æˆçŠ¶æ€
let game = {
    state: 'PLAY',
    score: 0,
    wave: 1,
    playerLevel: 1,
    frameCount: 0,
    input: { x: canvas.width/2, y: canvas.height/2 },
    player: null,
    enemies: [],
    playerBullets: [],
    enemyBullets: [],
    particles: [],
    
    async init() {
        this.player = new Player();
        window.addEventListener('mousemove', e => {
            this.input.x = e.clientX;
            this.input.y = e.clientY;
        });
        window.addEventListener('click', async () => {
            initAudio();
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
        });
        
        createLanterns();
        setInterval(createLanterns, 10000);
        
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    },
    
    restart() {
        this.state = 'PLAY';
        this.score = 0;
        this.wave = 1;
        this.playerLevel = 1;
        this.frameCount = 0;
        this.player = new Player();
        this.enemies = [];
        this.playerBullets = [];
        this.enemyBullets = [];
        this.particles = [];
        document.getElementById('game-over').style.display = 'none';
        this.updateUI();
    },
    
    spawnEnemy() {
        const params = getGameParams(this.playerLevel);
        
        // æ§åˆ¶åŒå±æ•Œäººæ•°é‡
        if (this.enemies.length >= params.maxEnemies) return;
        
        if (this.frameCount % params.spawnRate === 0) {
            const x = Math.random() * (canvas.width - 100) + 50;
            const rand = Math.random();
            let type = 'basic';
            
            // éšç­‰çº§å¢åŠ æ•Œäººç±»å‹å¤šæ ·æ€§
            if (this.playerLevel >= 3 && rand > 0.6) type = 'shooter';
            if (this.playerLevel >= 5 && rand > 0.8) type = 'tank';
            if (this.playerLevel >= 8 && rand > 0.9) type = 'fast';
            if (this.playerLevel % 5 === 0 && this.frameCount % 300 === 0) type = 'boss';
            
            this.enemies.push(new Enemy(x, -50, type, params));
        }
    },
    
    playerShoot() {
        const params = getGameParams(this.playerLevel);
        
        if (this.frameCount % params.fireRate === 0) {
            const bulletCount = params.bulletCount;
            const speed = params.bulletSpeed;
            
            // æ ¹æ®å­å¼¹æ•°é‡å†³å®šå‘å°„æ¨¡å¼
            if (bulletCount === 1) {
                // å•å‘
                this.playerBullets.push({
                    x: this.player.x, y: this.player.y - 10,
                    vx: 0, vy: -speed,
                    radius: 5,
                    color: CONFIG.colors.playerBullet
                });
            } else if (bulletCount === 2) {
                // åŒå‘
                this.playerBullets.push({
                    x: this.player.x - 15, y: this.player.y - 10,
                    vx: 0, vy: -speed,
                    radius: 5,
                    color: CONFIG.colors.playerBullet
                });
                this.playerBullets.push({
                    x: this.player.x + 15, y: this.player.y - 10,
                    vx: 0, vy: -speed,
                    radius: 5,
                    color: CONFIG.colors.playerBullet
                });
            } else {
                // æ•£å°„æ¨¡å¼ (3-5å‘)
                const spreadAngle = Math.PI / 8; // 22.5åº¦æ€»æ•£å¸ƒ
                const startAngle = -spreadAngle / 2;
                const angleStep = spreadAngle / (bulletCount - 1);
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = startAngle + angleStep * i - Math.PI / 2;
                    this.playerBullets.push({
                        x: this.player.x + Math.cos(angle) * 10,
                        y: this.player.y + Math.sin(angle) * 10,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 5,
                        color: CONFIG.colors.playerBullet
                    });
                }
            }
            playShootSound();
        }
    },
    
    createExplosion(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 1;
            this.particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                color: color
            });
        }
    },
    
    update() {
        if (this.state !== 'PLAY') return;
        
        this.frameCount++;
        const params = getGameParams(this.playerLevel);
        
        this.player.update(this.input.x, this.input.y);
        this.playerShoot();
        this.spawnEnemy();
        
        // æ›´æ–°æ•Œäºº
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const e = this.enemies[i];
            const newBullets = e.update(this.playerLevel);
            this.enemyBullets.push(...newBullets);
            
            if (!e.active) {
                this.enemies.splice(i, 1);
                continue;
            }
            
            // ç©å®¶å­å¼¹æ‰“æ•Œäºº
            for (let j = this.playerBullets.length - 1; j >= 0; j--) {
                const b = this.playerBullets[j];
                const dist = Math.hypot(b.x - e.x, b.y - e.y);
                
                if (dist < e.radius + b.radius) {
                    e.hp--;
                    this.createExplosion(b.x, b.y, 3, '#ff0');
                    this.playerBullets.splice(j, 1);
                    
                    if (e.hp <= 0) {
                        const points = e.type === 'boss' ? 500 : e.type === 'tank' ? 200 : e.type === 'shooter' ? 150 : 100;
                        this.score += points;
                        this.createExplosion(e.x, e.y, 15, CONFIG.colors.enemy);
                        this.enemies.splice(i, 1);
                        playExplosionSound();
                        
                        // æ¯500åˆ†å‡ä¸€çº§
                        const newLevel = Math.floor(this.score / 500) + 1;
                        if (newLevel > this.playerLevel) {
                            this.playerLevel = newLevel;
                            playLevelUpSound();
                        }
                        this.updateUI();
                        break;
                    }
                }
            }
        }
        
        // æ›´æ–°å­å¼¹
        for (let i = this.playerBullets.length - 1; i >= 0; i--) {
            const b = this.playerBullets[i];
            b.x += b.vx;
            b.y += b.vy;
            if (b.y < -20) this.playerBullets.splice(i, 1);
        }
        
        for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
            const b = this.enemyBullets[i];
            b.x += b.vx;
            b.y += b.vy;
            
            // å­å¼¹æ‰“ç©å®¶
            const dist = Math.hypot(b.x - this.player.x, b.y - this.player.y);
            if (dist < this.player.radius + b.radius) {
                this.player.health -= 15;
                playHitSound();
                this.enemyBullets.splice(i, 1);
                this.updateUI();
                
                if (this.player.health <= 0) {
                    this.state = 'GAMEOVER';
                    document.getElementById('blessing').textContent = blessings[Math.floor(Math.random() * blessings.length)];
                    document.getElementById('game-over').style.display = 'flex';
                }
                continue;
            }
            
            if (b.y > canvas.height + 20 || b.x < -20 || b.x > canvas.width + 20) {
                this.enemyBullets.splice(i, 1);
            }
        }
        
        // æ›´æ–°ç²’å­
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    },
    
    draw() {
        // æ¸å˜èƒŒæ™¯
        const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
        gradient.addColorStop(0, '#2d1810');
        gradient.addColorStop(1, '#1a0a0a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶æ˜Ÿæ˜ŸèƒŒæ™¯
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        for (let i = 0; i < 50; i++) {
            const x = (this.frameCount * 0.5 + i * 73) % canvas.width;
            const y = (i * 37) % canvas.height;
            ctx.beginPath();
            ctx.arc(x, y, 1, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç»˜åˆ¶ç©å®¶å­å¼¹
        ctx.save();
        this.playerBullets.forEach(b => {
            ctx.shadowBlur = 10;
            ctx.shadowColor = b.color;
            ctx.fillStyle = b.color;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.restore();
        
        // ç»˜åˆ¶æ•Œäººå­å¼¹
        ctx.save();
        this.enemyBullets.forEach(b => {
            ctx.shadowBlur = 8;
            ctx.shadowColor = b.color;
            ctx.fillStyle = b.color;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.restore();
        
        // ç»˜åˆ¶æ•Œäºº
        this.enemies.forEach(e => e.draw());
        
        // ç»˜åˆ¶ç©å®¶
        this.player.draw();
        
        // ç»˜åˆ¶ç²’å­
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    },
    
    updateUI() {
        document.getElementById('score').textContent = 'ğŸ§§ åˆ†æ•°: ' + this.score;
        document.getElementById('level').textContent = 'â­ ç­‰çº§: ' + this.playerLevel;
        
        // æ›´æ–°å‡çº§è¿›åº¦æ¡ (æ¯500åˆ†ä¸€çº§)
        const progress = (this.score % 500) / 500 * 100;
        document.getElementById('level-progress').style.width = progress + '%';
        
        const hpPercent = Math.max(0, this.player.health / CONFIG.playerHealth * 100);
        document.getElementById('health-fill').style.width = hpPercent + '%';
    },
    
    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
};

// ç©å®¶ç±»
class Player {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height - 100;
        this.radius = 12;
        this.health = CONFIG.playerHealth;
        this.targetX = this.x;
        this.targetY = this.y;
    }
    
    update(inputX, inputY) {
        this.targetX = inputX;
        this.targetY = inputY;
        this.x += (this.targetX - this.x) * CONFIG.playerSpeed;
        this.y += (this.targetY - this.y) * CONFIG.playerSpeed;
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
    }
    
    draw() {
        ctx.save();
        // é‡‘è‰²å…‰ç¯
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffd700';
        
        // é£æœºä¸»ä½“ - é‡‘è‰²
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 15);
        ctx.lineTo(this.x + 10, this.y + 10);
        ctx.lineTo(this.x, this.y + 5);
        ctx.lineTo(this.x - 10, this.y + 10);
        ctx.closePath();
        ctx.fill();
        
        // å†…éƒ¨çº¢è‰²è£…é¥°
        ctx.fillStyle = '#c41e3a';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 10);
        ctx.lineTo(this.x + 5, this.y + 5);
        ctx.lineTo(this.x, this.y);
        ctx.lineTo(this.x - 5, this.y + 5);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
}

// æ•Œäººç±»
class Enemy {
    constructor(x, y, type, params) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.active = true;
        this.timer = 0;
        this.params = params;
        
        switch(type) {
            case 'basic':
                this.radius = 18;
                this.hp = Math.floor(3 * params.enemyHpBonus);
                this.speed = 2 * params.enemySpeedBonus;
                this.score = 100;
                this.color = '#ff6b6b';
                break;
            case 'shooter':
                this.radius = 16;
                this.hp = Math.floor(5 * params.enemyHpBonus);
                this.speed = 1 * params.enemySpeedBonus;
                this.score = 200;
                this.color = '#ff8c00';
                break;
            case 'tank':
                this.radius = 25;
                this.hp = Math.floor(12 * params.enemyHpBonus);
                this.speed = 0.6 * params.enemySpeedBonus;
                this.score = 400;
                this.color = '#e74c3c';
                break;
            case 'fast':
                this.radius = 12;
                this.hp = Math.floor(2 * params.enemyHpBonus);
                this.speed = 4 * params.enemySpeedBonus;
                this.score = 150;
                this.color = '#ff00ff';
                break;
            case 'boss':
                this.radius = 40;
                this.hp = Math.floor(50 * params.enemyHpBonus);
                this.speed = 0.4 * params.enemySpeedBonus;
                this.score = 1000;
                this.color = '#c0392b';
                break;
        }
        this.maxHp = this.hp;
    }
    
    update(level) {
        this.timer++;
        
        // æ ¹æ®ç­‰çº§å¢åŠ å¼¹å¹•å¯†åº¦
        const shootInterval = Math.max(20, 80 - level * 3);
        
        switch(this.type) {
            case 'basic':
                this.y += this.speed;
                this.x += Math.sin(this.timer * 0.03) * 2;
                break;
            case 'fast':
                this.y += this.speed;
                this.x += Math.cos(this.timer * 0.05) * 3;
                break;
            case 'shooter':
                this.y += this.speed;
                if (this.timer % shootInterval === 0) {
                    return this.shootFan(level);
                }
                break;
            case 'tank':
                this.y += this.speed;
                if (this.timer % (shootInterval + 20) === 0) {
                    return this.shootAim(level);
                }
                break;
            case 'boss':
                this.x = canvas.width/2 + Math.sin(this.timer * 0.015) * 150;
                if (this.y < 120) this.y += this.speed;
                if (this.timer % Math.max(10, 30 - level) === 0) {
                    return this.shootBoss(level);
                }
                break;
        }
        
        if (this.y > canvas.height + 100) this.active = false;
        return [];
    }
    
    shootFan(level) {
        const bullets = [];
        // ç­‰çº§è¶Šé«˜ï¼Œæ‰‡å½¢å­å¼¹è¶Šå¤š
        const count = Math.min(8, 3 + Math.floor(level / 2));
        const speed = this.params.enemyBulletSpeed;
        
        for (let i = 0; i < count; i++) {
            const angle = Math.PI / 2 + (i - count/2) * 0.25;
            bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: 6,
                color: CONFIG.colors.enemyBullet
            });
        }
        return bullets;
    }
    
    shootAim(level) {
        const speed = this.params.enemyBulletSpeed * 1.2;
        return [{
            x: this.x, y: this.y,
            vx: 0, vy: speed,
            radius: 8,
            color: CONFIG.colors.enemyBullet
        }];
    }
    
    shootBoss(level) {
        const bullets = [];
        const speed = this.params.enemyBulletSpeed;
        
        // èºæ—‹å¼¹å¹•
        const angle = this.timer * 0.12;
        const spiralCount = Math.min(8, 4 + Math.floor(level / 3));
        for (let i = 0; i < spiralCount; i++) {
            const a = angle + i * (Math.PI * 2 / spiralCount);
            bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(a) * speed,
                vy: Math.sin(a) * speed,
                radius: 8,
                color: '#ff3838'
            });
        }
        
        // é¢å¤–è¿½è¸ªå¼¹
        if (level >= 5 && this.timer % 40 === 0) {
            for (let i = -3; i <= 3; i++) {
                bullets.push({
                    x: this.x, y: this.y,
                    vx: i * 0.8, vy: speed * 1.3,
                    radius: 6,
                    color: CONFIG.colors.enemyBullet
                });
            }
        }
        return bullets;
    }
    
    draw() {
        ctx.save();
        
        // è¡€æ¡
        const hpPercent = this.hp / this.maxHp;
        ctx.fillStyle = '#300';
        ctx.fillRect(this.x - 20, this.y - this.radius - 12, 40, 6);
        ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : '#f00';
        ctx.fillRect(this.x - 20, this.y - this.radius - 12, 40 * hpPercent, 6);
        
        // æ•Œäººæœ¬ä½“ - å–œåº†çº¢è‰²ç³»
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        
        if (this.type === 'boss') {
            // BOSS - å¤§çº¢åœ†å½¢
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // å†…éƒ¨è£…é¥°
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('å¹´', this.x, this.y + 7);
        } else {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // é‡‘è‰²è¾¹æ¡†
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

// å¯åŠ¨æ¸¸æˆ
game.init();
game.updateUI();

// çª—å£è°ƒæ•´
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>